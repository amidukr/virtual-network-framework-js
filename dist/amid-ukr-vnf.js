/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var Vnf;
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vnf\": () => (/* reexport safe */ _vnf_vnf_js__WEBPACK_IMPORTED_MODULE_0__.Vnf)\n/* harmony export */ });\n/* harmony import */ var _vnf_vnf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vnf/vnf.js */ \"./src/vnf/vnf.js\");\n\r\n\r\n\n\n//# sourceURL=webpack://Vnf/./src/index.js?");

/***/ }),

/***/ "./src/utils/arrays.js":
/*!*****************************!*\
  !*** ./src/utils/arrays.js ***!
  \*****************************/
/***/ (() => {

eval("Array.prototype.removeValue = function(value) {\r\n\tvar offset = this.indexOf(value);\r\n\r\n    if( offset == -1) return false;\r\n\r\n    this.splice(offset, 1);\r\n    return true;\r\n}\r\n\r\nif (typeof Object.assign != 'function') {\r\n  Object.assign = function(target) {\r\n    'use strict';\r\n    if (target == null) {\r\n      throw new TypeError('Cannot convert undefined or null to object');\r\n    }\r\n\r\n    target = Object(target);\r\n    for (var index = 1; index < arguments.length; index++) {\r\n      var source = arguments[index];\r\n      if (source != null) {\r\n        for (var key in source) {\r\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\r\n            target[key] = source[key];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return target;\r\n  };\r\n}\n\n//# sourceURL=webpack://Vnf/./src/utils/arrays.js?");

/***/ }),

/***/ "./src/utils/cycle-buffer.js":
/*!***********************************!*\
  !*** ./src/utils/cycle-buffer.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CycleBuffer\": () => (/* binding */ CycleBuffer)\n/* harmony export */ });\nfunction CycleBuffer() {\r\n    var self = this;\r\n\r\n    self.array = [];\r\n    self.beginPointer = 0;\r\n    self.endPointer = 0;\r\n    self.length = 0;\r\n\r\n    self.setValue = function(index, value) {\r\n        if(index >= self.array.length) {\r\n            if(self.beginPointer != 0) {\r\n                self.array = self.toArray();\r\n                self.beginPointer = 0;\r\n            }\r\n\r\n            self.array.length = index + 1\r\n        }\r\n\r\n        var arrayLength = self.array.length;\r\n        var pointerToSet = (index + self.beginPointer) % arrayLength;\r\n\r\n        if(index >= self.length) {\r\n            for(var i = self.length; i < index; i++) {\r\n                delete self.array[(i + self.beginPointer) % arrayLength];\r\n            }\r\n\r\n            self.endPointer = pointerToSet+1;\r\n            self.length = index + 1;\r\n        }\r\n\r\n        self.array[pointerToSet] = value;\r\n    }\r\n\r\n    self.push = function(element) {\r\n        if(self.beginPointer != 0) {\r\n            if(self.beginPointer == self.endPointer) {\r\n                self.array = self.toArray();\r\n                self.beginPointer = 0;\r\n                self.endPointer = self.array.length;\r\n            }else{\r\n                self.endPointer %= self.array.length;\r\n            }\r\n        }\r\n\r\n        self.array[self.endPointer++] = element;\r\n        self.length++;\r\n    };\r\n\r\n    self.removeFirst = function(amount) {\r\n        if(amount >= self.length) {\r\n            self.beginPointer = 0;\r\n            self.endPointer = 0;\r\n            self.length = 0;\r\n        }else{\r\n            self.beginPointer += amount\r\n            self.beginPointer %= self.array.length;\r\n            self.length -= amount;\r\n        }\r\n    }\r\n\r\n    self.toArray = function() {\r\n        var beginPointer = self.beginPointer;\r\n        var endPointer = self.endPointer;\r\n        var array = self.array;\r\n\r\n        if(beginPointer == 0 && endPointer == 0) {\r\n            return [];\r\n        }\r\n\r\n        if(endPointer > beginPointer) {\r\n            return array.slice(beginPointer, endPointer);\r\n        }\r\n\r\n        var result = array.slice(beginPointer);\r\n\r\n        result.push.apply(result, array.slice(0, endPointer));\r\n\r\n        return result;\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://Vnf/./src/utils/cycle-buffer.js?");

/***/ }),

/***/ "./src/utils/logger.js":
/*!*****************************!*\
  !*** ./src/utils/logger.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ERROR\": () => (/* binding */ ERROR),\n/* harmony export */   \"WARN\": () => (/* binding */ WARN),\n/* harmony export */   \"INFO\": () => (/* binding */ INFO),\n/* harmony export */   \"DEBUG\": () => (/* binding */ DEBUG),\n/* harmony export */   \"VERBOSE\": () => (/* binding */ VERBOSE),\n/* harmony export */   \"Log\": () => (/* binding */ Log)\n/* harmony export */ });\n\r\n// Usage example:\r\n//  Log.debug(\"instance-id\", \"category\", \"message\")\r\n//  Log.debug(\"category\", \"message\")\r\n\r\nconst ERROR = 0;\r\nconst WARN  = 1;\r\nconst INFO = 2;\r\nconst DEBUG = 3;\r\nconst VERBOSE = 4;\r\n\r\nvar logLevelMap = {\r\n    \"error\": ERROR,\r\n    \"warn\": WARN,\r\n    \"info\": INFO,\r\n    \"debug\": DEBUG,\r\n    \"verbose\": VERBOSE\r\n}\r\n\r\nvar defaultLevel = INFO;\r\n\r\nvar categoryLogLevel = {}\r\n\r\nclass Log {\r\n    static setDefaultLogLevel(value) {\r\n        defaultLevel = value;\r\n    }\r\n\r\n    static log(level, instance, category, message) {\r\n        var allowedLogLevel = categoryLogLevel[category] || defaultLevel;\r\n        var currentLogLevel = logLevelMap[level];\r\n\r\n        if(allowedLogLevel < currentLogLevel) return;\r\n\r\n        if(message == undefined) {\r\n            message = category;\r\n            category = instance;\r\n            instance = undefined;\r\n        }\r\n\r\n        var event = {level: level,\r\n                   instance: instance,\r\n                   category: category,\r\n                   message: message};\r\n\r\n        var formattedDate = Date.prototype.toISOString ? new Date().toISOString() : \"\";\r\n\r\n        var args;\r\n        if(instance) {\r\n            args = [formattedDate + \" [\" + category + \"] - [\" + instance  + \"]: \"];\r\n        }else{\r\n            args = [formattedDate + \" [\" + category + \"]: \"];\r\n        }\r\n\r\n        if(message && message.constructor.name == \"Array\" ) {\r\n            args.push.apply(args, message);\r\n        }else{\r\n            args.push(message);\r\n        }\r\n\r\n        var logMethod = level == 'verbose' ? \"debug\" : level;\r\n        console[logMethod].apply(console[level], args);\r\n    }\r\n\r\n    static verbose(instance, category, message) {\r\n        Log.log(\"verbose\", instance, category, message)\r\n    }\r\n\r\n    static debug(instance, category, message) {\r\n        Log.log(\"debug\", instance, category, message)\r\n    }\r\n\r\n    static info(instance, category, message) {\r\n        Log.log(\"info\", instance, category, message)\r\n    }\r\n\r\n    static warn(instance, category, message) {\r\n        Log.log(\"warn\", instance, category, message)\r\n    }\r\n\r\n    static error(instance, category, message) {\r\n        Log.log(\"error\", instance, category, message)\r\n    }\r\n};\n\n//# sourceURL=webpack://Vnf/./src/utils/logger.js?");

/***/ }),

/***/ "./src/utils/observable.js":
/*!*********************************!*\
  !*** ./src/utils/observable.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Observable\": () => (/* binding */ Observable)\n/* harmony export */ });\n/* harmony import */ var _logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger.js */ \"./src/utils/logger.js\");\n\r\n\r\nfunction Observable() {\r\n    var self = this;\r\n\r\n    var listeners = [];\r\n\r\n    self.addListener = function addListener(listener) {\r\n        listeners[listeners.length] = listener;\r\n    }\r\n\r\n    self.fire = function fire() {\r\n        for(var i = 0; i < listeners.length; i++) {\r\n            try{\r\n                listeners[i].apply(null, arguments);\r\n            }catch(e) {\r\n                _logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(\"observable-error\", [\"Listener thrown error\", e]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://Vnf/./src/utils/observable.js?");

/***/ }),

/***/ "./src/utils/random.js":
/*!*****************************!*\
  !*** ./src/utils/random.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Random\": () => (/* binding */ Random)\n/* harmony export */ });\nclass Random {\r\n    static random6() {\r\n        return Math.floor((1 + Math.random()) * 0x10000000).toString(36);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://Vnf/./src/utils/random.js?");

/***/ }),

/***/ "./src/utils/utils.js":
/*!****************************!*\
  !*** ./src/utils/utils.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Utils\": () => (/* binding */ Utils)\n/* harmony export */ });\nclass Utils{\r\n    static isEmptyObject(obj) {\r\n        for(var prop in obj) {\r\n            if(obj.hasOwnProperty(prop)) return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://Vnf/./src/utils/utils.js?");

/***/ }),

/***/ "./src/utils/vnf-serializer.js":
/*!*************************************!*\
  !*** ./src/utils/vnf-serializer.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VnfSerializer\": () => (/* binding */ VnfSerializer)\n/* harmony export */ });\nclass VnfSerializer {\r\n    static serializeValue(value) {\r\n        if(typeof value == \"string\") return \"S\" + value;\r\n\r\n        return \"J\" + JSON.stringify(value);\r\n    }\r\n\r\n    static deserializeValue(value) {\r\n        if(value == null || value == \"\") return value;\r\n\r\n        var formatType = value.charAt(0);\r\n        var message = value.substr(1);\r\n\r\n        if(formatType == \"S\") return message;\r\n        if(formatType == \"J\") return JSON.parse(message);\r\n\r\n        throw new Error(\"Unexpected message format: '\" + formatType + \"', for message: \" + message);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://Vnf/./src/utils/vnf-serializer.js?");

/***/ }),

/***/ "./src/utils/xtimeout.js":
/*!*******************************!*\
  !*** ./src/utils/xtimeout.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"xTimeout\": () => (/* binding */ xTimeout)\n/* harmony export */ });\nfunction xTimeout(timeout, callback) {\r\n    if(callback == undefined) {\r\n        callback = timeout;\r\n        timeout = -1;\r\n    }\r\n\r\n    var timeoutID;\r\n    var triggered = false;\r\n\r\n    function timeoutCallback() {\r\n        if(triggered) return;\r\n\r\n        window.clearTimeout(timeoutID);\r\n\r\n        triggered = true;\r\n        callback();\r\n    }\r\n\r\n    if(timeout > -1) {\r\n        timeoutID = window.setTimeout(timeoutCallback, timeout);\r\n    }\r\n\r\n    return {\r\n        extend: function(newTimeout) {\r\n            if(triggered) return;\r\n\r\n            window.clearTimeout(timeoutID);\r\n            timeoutID = window.setTimeout(timeoutCallback, newTimeout);\r\n        },\r\n\r\n        trigger: function() {\r\n            timeoutCallback();\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://Vnf/./src/utils/xtimeout.js?");

/***/ }),

/***/ "./src/vnf/channel/base/vnf-hub.js":
/*!*****************************************!*\
  !*** ./src/vnf/channel/base/vnf-hub.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VnfHub\": () => (/* binding */ VnfHub)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _utils_observable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/observable.js */ \"./src/utils/observable.js\");\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../global.js */ \"./src/vnf/global.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nwindow.vnfActiveEndpoints = [];\r\n    \r\nfunction VnfHub(){\r\n    var selfHub = this;\r\n\r\n    var hub = {};\r\n\r\n    var openConnectionRetries = 3;\r\n    var retryConnectAfterDelay = 0;\r\n    var establishConnectionTimeout = 5000;\r\n\r\n    selfHub.setEstablishConnectionTimeout = function(value) {\r\n        establishConnectionTimeout = value;\r\n    }\r\n\r\n    selfHub.setRetryConnectAfterDelay = function(value) {\r\n        retryConnectAfterDelay = value;\r\n    }\r\n\r\n    selfHub.setOpenConnectionRetries = function(value) {\r\n        openConnectionRetries = value;\r\n    }\r\n\r\n    selfHub.BaseEndPoint = function BaseEndPoint(selfEva) {\r\n        var self = this;\r\n        var destroyListeners = new _utils_observable_js__WEBPACK_IMPORTED_MODULE_1__.Observable();\r\n        var connectionOpenListeners = new _utils_observable_js__WEBPACK_IMPORTED_MODULE_1__.Observable();\r\n        var connectionLostListeners = new _utils_observable_js__WEBPACK_IMPORTED_MODULE_1__.Observable();\r\n\r\n        var connections = {}\r\n        var connectionsArray = null;\r\n\r\n        var anyTypeSupported = false;\r\n\r\n        window.vnfActiveEndpoints.push(self);\r\n\r\n        self.eva = selfEva;\r\n\r\n        self.onMessage = null;\r\n        var destroyed = false;\r\n\r\n        function notifyConnectionSuccess(targetEva, callback) {\r\n            try{\r\n                callback({\r\n                    status: _global_js__WEBPACK_IMPORTED_MODULE_2__.Global.CONNECTED,\r\n                    targetEva: targetEva,\r\n                    endpoint: self\r\n                });\r\n            }catch(e) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(selfEva, [\"vnf-hub\", \"Error in connection callback\\n\", e]);\r\n            }\r\n        }\r\n\r\n        function notifyConnectionFailed(targetEva, callback) {\r\n            try{\r\n                callback({\r\n                    status: _global_js__WEBPACK_IMPORTED_MODULE_2__.Global.FAILED,\r\n                    targetEva: targetEva,\r\n                    endpoint: self\r\n                });\r\n            }catch(e) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(selfEva, [\"vnf-hub\", \"Error in connection callback\\n\", e]);\r\n            }\r\n        }\r\n\r\n        function destroyConnection(connection) {\r\n            if(connection.isDestroyed) return;\r\n            connection.isDestroyed = true;\r\n\r\n            if(connections[connection.targetEva] == connection) {\r\n                delete connections[connection.targetEva];\r\n                connectionsArray = null;\r\n\r\n                var __doReleaseConnection = self.__doReleaseConnection;\r\n                if(__doReleaseConnection) {\r\n                    __doReleaseConnection(connection);\r\n                }\r\n\r\n                if(connection.isConnected) {\r\n                    connectionLostListeners.fire(connection.targetEva);\r\n                }\r\n            }\r\n\r\n            if(!connection.isConnected && connection.callback) {\r\n                notifyConnectionFailed(connection.targetEva, connection.callback);\r\n                connection.callback = null;\r\n            }\r\n\r\n            connection.isConnected = false;\r\n        }\r\n\r\n        self.setAnyTypeSupported = function(value) {\r\n            anyTypeSupported = value;\r\n        }\r\n\r\n        self.isConnected = function isConnected(targetEva) {\r\n            var connection = connections[targetEva];\r\n            return connection != null && connection.isConnected;\r\n        }\r\n\r\n        self.getConnections = function() {\r\n            if(connectionsArray == null) {\r\n                connectionsArray = [];\r\n                for(var eva in connections) {\r\n                    connectionsArray.push(connections[eva]);\r\n                }\r\n            }\r\n\r\n            return connectionsArray;\r\n        }\r\n\r\n        self.getConnection = function(targetEva) {\r\n            return connections[targetEva];\r\n        }\r\n\r\n        self.__lazyNewConnection = function(targetEva) {\r\n            var connection = connections[targetEva];\r\n            if(!connection) {\r\n                connection = {isConnected: false,\r\n                              destroyed: false,\r\n                              openConnectionRetriesLeft: 0,\r\n                              targetEva: targetEva};\r\n                connections[targetEva] = connection;\r\n\r\n                connectionsArray = null;\r\n            }\r\n\r\n            return connection;\r\n        }\r\n\r\n        self.__acceptConnection = function(targetEva) {\r\n            var connection = self.__lazyNewConnection(targetEva);\r\n\r\n            if(connection.isDestroyed || connection.isConnected) {\r\n                return;\r\n            }\r\n\r\n            self.__connectionOpened(connection);\r\n        }\r\n\r\n        self.__connectionOpened = function(connection) {\r\n\r\n            if(connection.isDestroyed || connection.isConnected) {\r\n                return;\r\n            }\r\n\r\n            connection.isConnected = true;\r\n\r\n            connectionOpenListeners.fire(connection.targetEva);\r\n\r\n            var callback = connection.callback;\r\n            connection.callback = null;\r\n            if(callback) {\r\n                notifyConnectionSuccess(connection.targetEva, callback);\r\n            }\r\n        }\r\n\r\n        self.__connectionOpenFailed = function(connection) {\r\n            if(connection.isDestroyed) {\r\n                return;\r\n            }\r\n\r\n            if(connection.isConnected) {\r\n                throw new Error(\"Wrong state, connection is already established.\");\r\n            }\r\n\r\n            destroyConnection(connection);\r\n        }\r\n\r\n        self.__connectionNextTryFailed = function(connection) {\r\n            if(connection.retryTimeoutToken) {\r\n                window.clearTimeout(connection.retryTimeoutToken);\r\n                connection.retryTimeoutToken = null;\r\n            }\r\n\r\n            if(connection.isConnected || connection.isDestroyed) {\r\n                return;\r\n            }\r\n\r\n            if(connection.openConnectionRetriesLeft-- > 0) {\r\n                if(self.__doOpenConnection_CleanBeforeNextTry) self.__doOpenConnection_CleanBeforeNextTry(connection);\r\n                window.setTimeout(self.__doOpenConnectionRetryLoop.bind(null, connection), retryConnectAfterDelay);\r\n            }else{\r\n                self.__connectionOpenFailed(connection);\r\n            }\r\n        }\r\n\r\n        self.__rejectConnection = function(connection) {\r\n            if(connection.isDestroyed) {\r\n                return;\r\n            }\r\n\r\n            if(connection.isConnected) {\r\n                self.closeConnection(connection.targetEva);\r\n            }else{\r\n                self.__connectionNextTryFailed(connection);\r\n            }\r\n        }\r\n\r\n        self.__doOpenConnectionRetryLoop = function __doOpenConnectionRetryLoop(connection) {\r\n            if(connection.isConnected || connection.isDestroyed) {\r\n                return;\r\n            }\r\n\r\n            if(self.__doOpenConnection_NextTry) self.__doOpenConnection_NextTry(connection);\r\n            connection.retryTimeoutToken = window.setTimeout(self.__connectionNextTryFailed.bind(self, connection), establishConnectionTimeout);\r\n        }\r\n\r\n        self.openConnection = function openConnection(targetEva, callback) {\r\n            if(typeof targetEva != \"string\")   throw new Error(\"Wrong first argument type, targetEva as string is expected\");\r\n            if(typeof callback  != \"function\") throw new Error(\"Wrong second argument type, callback as function is expected\");\r\n\r\n            if(self.isDestroyed()) {\r\n                throw new Error(\"Endpoint is destroyed\");\r\n            }\r\n\r\n            if(self.isConnected(targetEva)) {\r\n                notifyConnectionSuccess(targetEva, callback);\r\n                return;\r\n            }\r\n\r\n            var isNewConnection = connections[targetEva] == null;\r\n            var connection = self.__lazyNewConnection(targetEva);\r\n            connection.callback = callback;\r\n\r\n            if(isNewConnection) {\r\n                if(targetEva == selfEva) {\r\n                    window.setTimeout(self.__connectionOpened.bind(null, connection), 0)\r\n                }else{\r\n                    connection.openConnectionRetriesLeft = openConnectionRetries;\r\n                    if(self.__doOpenConnection) self.__doOpenConnection(connection);\r\n                    self.__doOpenConnectionRetryLoop(connection);\r\n                }\r\n            }\r\n        }\r\n\r\n        self.send = function(targetEva, message) {\r\n            if(typeof targetEva != \"string\")\r\n                throw new Error(\"Wrong first argument type, targetEva as string is expected\");\r\n            if(!anyTypeSupported && typeof message   != \"string\")\r\n                throw new Error(\"Wrong second argument type, message - only string is supported\");\r\n\r\n            if(self.isDestroyed()) throw new Error(\"Endpoint is destroyed\");\r\n\r\n            var connection = connections[targetEva];\r\n            if(!connection || !connection.isConnected) {\r\n                throw new Error(\"Connection to endpoint '\" + targetEva + \"' isn't established\");\r\n            }\r\n\r\n            if(targetEva == selfEva) {\r\n                window.setTimeout(function(){\r\n                    try{\r\n                        self.onMessage && self.onMessage({sourceEva: selfEva, message: message, endpoint: self});\r\n                    }catch(e) {\r\n                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(\"vnf-hub\", [\"Error in onMessage handler: \", e]);\r\n                    }\r\n\r\n                }, 0);\r\n            }else{\r\n                self.__doSend(connection, message);\r\n            }\r\n        }\r\n\r\n\r\n        self.closeConnection = function(targetEva) {\r\n            if(typeof targetEva != \"string\")   throw new Error(\"Wrong first argument type, targetEva as string is expected\");\r\n\r\n            var connection = connections[targetEva];\r\n            if(!connection) {\r\n                return;\r\n            }\r\n\r\n            destroyConnection(connection);\r\n        }\r\n\r\n        self.isDestroyed = function() {\r\n            return destroyed;\r\n        }\r\n\r\n        self.onDestroy = destroyListeners.addListener;\r\n\r\n        self.onConnectionOpen = connectionOpenListeners.addListener;\r\n        self.onConnectionLost = connectionLostListeners.addListener;\r\n\r\n        self.destroy = function() {\r\n            if(destroyed) return;\r\n            destroyed = true;\r\n\r\n            for(var targetEva in connections){\r\n                try{\r\n                    self.closeConnection(targetEva);\r\n                }catch(e){\r\n                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(selfEva, \"vnf-hub\", [\"Error closing connection\", e]);\r\n                }\r\n            }\r\n\r\n            delete hub[selfEva];\r\n\r\n            destroyListeners.fire();\r\n\r\n            window.vnfActiveEndpoints.removeValue(self);\r\n        }\r\n    }\r\n\r\n    selfHub.getEndPoint = function(eva) {\r\n       return hub[eva];\r\n    }\r\n\r\n    selfHub.openEndpoint = function openEndpoint(eva) {\r\n       var endpoint = hub[eva];\r\n       if(!endpoint) {\r\n            endpoint = new selfHub.VnfEndpoint(eva);\r\n            hub[eva] = endpoint;\r\n       }\r\n\r\n       return endpoint;\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/channel/base/vnf-hub.js?");

/***/ }),

/***/ "./src/vnf/channel/base/vnf-proxy-hub.js":
/*!***********************************************!*\
  !*** ./src/vnf/channel/base/vnf-proxy-hub.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ProxyHub\": () => (/* binding */ ProxyHub)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _vnf_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vnf-hub.js */ \"./src/vnf/channel/base/vnf-hub.js\");\n\r\n\r\n\r\n\r\nfunction ProxyHub(parentHub){\r\n    var selfHub = this;\r\n\r\n    if(!parentHub) {\r\n        throw new Error(\"Unable to create instnce of ProxyHub, argument 'parentHub' shouldn't be null\");\r\n    }\r\n\r\n    _vnf_hub_js__WEBPACK_IMPORTED_MODULE_1__.VnfHub.call(selfHub);\r\n\r\n    selfHub.setEstablishConnectionTimeout = function(value) {\r\n        parentHub.setEstablishConnectionTimeout(value);\r\n    }\r\n\r\n    selfHub.setRetryConnectAfterDelay = function(value) {\r\n        parentHub.setRetryConnectAfterDelay(value);\r\n    }\r\n\r\n    selfHub.setOpenConnectionRetries = function(value) {\r\n        parentHub.setOpenConnectionRetries(value);\r\n    }\r\n\r\n    selfHub.ProxyEndpoint = function ProxyEndpoint(selfEva) {\r\n        var self = this;\r\n        selfHub.BaseEndPoint.call(this, selfEva);\r\n\r\n        self.parentEndpoint = parentHub.openEndpoint(selfEva);\r\n\r\n        self.onDestroy(function selfOnDestroyCallback(){\r\n            if(self.parentEndpoint) {\r\n                self.parentEndpoint.destroy();\r\n            }\r\n        });\r\n\r\n        self.__doReleaseConnection = function(connection) {\r\n            if(self.parentEndpoint) {\r\n                self.parentEndpoint.closeConnection(connection.targetEva);\r\n            }\r\n        };\r\n    }\r\n};\n\n//# sourceURL=webpack://Vnf/./src/vnf/channel/base/vnf-proxy-hub.js?");

/***/ }),

/***/ "./src/vnf/channel/in-browser-hub.js":
/*!*******************************************!*\
  !*** ./src/vnf/channel/in-browser-hub.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InBrowserHub\": () => (/* binding */ InBrowserHub)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _base_vnf_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base/vnf-hub.js */ \"./src/vnf/channel/base/vnf-hub.js\");\n\r\n\r\n\r\n\r\nfunction InBrowserHub(){\r\n    var selfHub = this;\r\n\r\n    _base_vnf_hub_js__WEBPACK_IMPORTED_MODULE_1__.VnfHub.call(selfHub);\r\n\r\n    var immediateSend = false;\r\n\r\n    selfHub.setImmediateSend = function(value) {\r\n        immediateSend = value;\r\n    }\r\n\r\n    selfHub.VnfEndpoint = function InBrowserEndpoint(selfEva) {\r\n        var self = this;\r\n        selfHub.BaseEndPoint.call(this, selfEva);\r\n\r\n        self.__doOpenConnection_NextTry = function(connection) {\r\n            window.setTimeout(function __doOpenConnectionTimerCallback(){\r\n                if(connection.isConnected || connection.isDestroyed) {\r\n                    return;\r\n                }\r\n\r\n                var remoteEndpoint = selfHub.getEndPoint(connection.targetEva);\r\n\r\n                if(remoteEndpoint) {\r\n\r\n                    connection.remoteEndpoint = remoteEndpoint;\r\n\r\n                    var remoteConnection = remoteEndpoint.__lazyNewConnection(selfEva);\r\n                    remoteConnection.remoteEndpoint = self;\r\n                    remoteEndpoint.__acceptConnection(selfEva);\r\n\r\n                    self.__connectionOpened(connection);\r\n                }else{\r\n                    self.__connectionNextTryFailed(connection);\r\n                }\r\n            }, 0);\r\n        }\r\n\r\n        function sendFunction(connection, message) {\r\n            var remoteEndpoint = connection.remoteEndpoint;\r\n\r\n            if(!remoteEndpoint)  return;\r\n            if(remoteEndpoint.isDestroyed()) return;\r\n            var remoteConnection = remoteEndpoint.getConnection(selfEva);\r\n\r\n            if(!remoteConnection || remoteConnection.remoteEndpoint != self) return;\r\n\r\n            var onMessage = remoteEndpoint.onMessage;\r\n\r\n            try{\r\n                onMessage && onMessage({sourceEva: selfEva, message: message, endpoint: remoteEndpoint});\r\n            }catch(e) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(selfEva, \"in-browser-message\", [\"Error in onMessage handler: \", e]);\r\n            }\r\n        }\r\n\r\n        self.__doSend = function(connection, message) {\r\n            if(immediateSend) {\r\n                sendFunction(connection, message);\r\n            }else{\r\n                window.setTimeout(sendFunction.bind(null, connection, message), 0);\r\n            }\r\n        }\r\n\r\n        self.__doReleaseConnection = function(connection) {\r\n             var remoteEndpoint = connection.remoteEndpoint;\r\n             if(remoteEndpoint && remoteEndpoint.isConnected(selfEva)) {\r\n                window.setTimeout(remoteEndpoint.closeConnection.bind(null, selfEva), 0);\r\n             }\r\n        }\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/channel/in-browser-hub.js?");

/***/ }),

/***/ "./src/vnf/channel/marshaller-channel.js":
/*!***********************************************!*\
  !*** ./src/vnf/channel/marshaller-channel.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MarshallerHub\": () => (/* binding */ MarshallerHub)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _utils_xtimeout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/xtimeout.js */ \"./src/utils/xtimeout.js\");\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../global.js */ \"./src/vnf/global.js\");\n/* harmony import */ var _base_vnf_proxy_hub_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base/vnf-proxy-hub.js */ \"./src/vnf/channel/base/vnf-proxy-hub.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nvar DEFAULT_FRAGMENT_SIZE = 64*1024;\r\n\r\nfunction MarshallerHub(parentHub, configuration){\r\n    var selfHub = this;\r\n    _base_vnf_proxy_hub_js__WEBPACK_IMPORTED_MODULE_3__.ProxyHub.call(selfHub, parentHub);\r\n\r\n    configuration = configuration || {}\r\n    var fragmentSize = configuration.fragmentSize || DEFAULT_FRAGMENT_SIZE;\r\n\r\n    selfHub.VnfEndpoint = function BigMessageEndpoint(selfEva) {\r\n        var self = this;\r\n        selfHub.ProxyEndpoint.call(self, selfEva);\r\n\r\n        var parentEndpoint = self.parentEndpoint;\r\n\r\n        self.setAnyTypeSupported(true);\r\n\r\n        parentEndpoint.onConnectionOpen(function(targetEva){\r\n            self.__acceptConnection(targetEva);\r\n        })\r\n\r\n        parentEndpoint.onConnectionLost(function(targetEva){\r\n            self.closeConnection(targetEva);\r\n        });\r\n\r\n        parentEndpoint.onMessage = function(event) {\r\n            var connection = self.__lazyNewConnection(event.sourceEva);\r\n\r\n            var message = event.message;\r\n\r\n            var messageLen = connection.messageLen;\r\n\r\n            if(messageLen == null) {\r\n                // First fragment of new message\r\n                connection.messageType = message.substr(0, 1);\r\n                var lenDigit = message.substr(1, 1) - 0;\r\n                connection.messageLen = message.substr(2, lenDigit) - 0;\r\n                connection.messageFragment = message.substr(2 + lenDigit);\r\n\r\n                messageLen = connection.messageLen;\r\n            } else {\r\n                connection.messageFragment += message;\r\n            }\r\n\r\n            var messageFragment = connection.messageFragment;\r\n\r\n            if(messageFragment.length == messageLen) {\r\n                connection.messageLen = null;\r\n\r\n                var message = connection.messageType == \"J\" ? JSON.parse(messageFragment) : messageFragment;\r\n\r\n                var onMessage = self.onMessage;\r\n                try {\r\n                    onMessage && onMessage({message: message,\r\n                                            sourceEva: event.sourceEva,\r\n                                            endpoint: self});\r\n                }catch(e) {\r\n                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(selfEva, \"big-message\", [\"Error in onMessage handler: \", e]);\r\n                }\r\n\r\n                connection.messageFragment = null;\r\n                connection.messageType = null;\r\n            }\r\n        }\r\n\r\n        self.__doOpenConnection = function(connection) {\r\n            parentEndpoint.openConnection(connection.targetEva, function(event) {\r\n                if(event.status == _global_js__WEBPACK_IMPORTED_MODULE_2__.Global.FAILED) {\r\n                    self.__connectionOpenFailed(connection);\r\n                }else{\r\n                    self.__connectionOpened(connection);\r\n                }\r\n            })\r\n        }\r\n\r\n        self.__doSend = function(connection, message) {\r\n            var messageData;\r\n            var messageType;\r\n\r\n            if(typeof message == \"string\") {\r\n                messageData = message;\r\n                messageType = \"S\";\r\n            }else{\r\n                messageData = JSON.stringify(message);\r\n                messageType = \"J\";\r\n            }\r\n\r\n            var msgLen = messageData.length + \"\";\r\n            var lenDigit = msgLen.length + \"\";\r\n            if(lenDigit.length > 1) {\r\n                throw new Error(\"Message length to big: \" + msgLen);\r\n            }\r\n\r\n            var position = 0;\r\n\r\n            while(position < msgLen) {\r\n                var msgChunk = messageData.substr(position, fragmentSize);\r\n                var fragment = position == 0 ? messageType + lenDigit + msgLen +  msgChunk : msgChunk;\r\n                parentEndpoint.send(connection.targetEva, fragment);\r\n                position += msgChunk.length;\r\n            }\r\n        }\r\n\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/channel/marshaller-channel.js?");

/***/ }),

/***/ "./src/vnf/channel/reliable-hub.js":
/*!*****************************************!*\
  !*** ./src/vnf/channel/reliable-hub.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ReliableHub\": () => (/* binding */ ReliableHub)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _utils_cycle_buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/cycle-buffer.js */ \"./src/utils/cycle-buffer.js\");\n/* harmony import */ var _utils_random_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/random.js */ \"./src/utils/random.js\");\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../global.js */ \"./src/vnf/global.js\");\n/* harmony import */ var _base_vnf_proxy_hub_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base/vnf-proxy-hub.js */ \"./src/vnf/channel/base/vnf-proxy-hub.js\");\n/* harmony import */ var _reliable_reliable_message_serializer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./reliable/reliable-message-serializer.js */ \"./src/vnf/channel/reliable/reliable-message-serializer.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar STATE_NO_ACTION   = 'NO-ACTION';\r\nvar STATE_HANDSHAKING = 'HANDSHAKING';\r\nvar STATE_ACCEPTING   = 'ACCEPTING';\r\nvar STATE_CONNECTED   = 'CONNECTED';\r\nvar STATE_CLOSED      = 'CLOSED';\r\n\r\nvar MESSAGE_HANDSHAKE    = 'HANDSHAKE';\r\nvar MESSAGE_ACCEPT       = 'ACCEPT';\r\nvar MESSAGE_DATA         = 'MESSAGE';\r\nvar MESSAGE_HEARTBEAT    = 'HEARTBEAT';\r\nvar MESSAGE_CLOSE_CONNECTION  = 'CLOSE-CONNECTION';\r\nvar MESSAGE_CLOSE_ACCEPT = 'CLOSE-ACCEPT';\r\n\r\n\r\nfunction ReliableHub(hub) {\r\n    var selfHub = this;\r\n\r\n    _base_vnf_proxy_hub_js__WEBPACK_IMPORTED_MODULE_4__.ProxyHub.call(selfHub, hub);\r\n\r\n    if(!hub) {\r\n        throw new Error(\"Unable to create instance of ReliableHub, argument 'hub' cannot be null\");\r\n    }\r\n\r\n    var heartbeatInterval = 1000;\r\n    var connectionInvalidateInterval = 50000;\r\n    var connectionLostTimeout = 15000;\r\n\r\n    var heartbeatsToInvalidate = 0;\r\n    var heartbeatsToDropConnection = 0;\r\n\r\n    var heartbeatDeviation = 0.3;\r\n\r\n    selfHub.setEstablishConnectionTimeout = function(value) {\r\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.warn(\"reliable-hub\", \"ReliableHub do not support setEstablishConnectionTimeout, please use ReliableHub heartbeat specific configure\");\r\n    }\r\n\r\n    selfHub.setRetryConnectAfterDelay = function(value) {\r\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.warn(\"reliable-hub\", \"ReliableHub do not support setEstablishConnectionTimeout, please use ReliableHub heartbeat specific configure\");\r\n    }\r\n\r\n    selfHub.setOpenConnectionRetries = function(value) {\r\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.warn(\"reliable-hub\", \"ReliableHub do not support setEstablishConnectionTimeout, please use ReliableHub heartbeat specific configure\");\r\n    }\r\n\r\n\r\n    function updateHeartbeatCounters() {\r\n        heartbeatsToInvalidate     = Math.round(connectionInvalidateInterval / heartbeatInterval);\r\n        heartbeatsToDropConnection = Math.round(connectionLostTimeout        / heartbeatInterval);\r\n    }\r\n\r\n    updateHeartbeatCounters();\r\n\r\n    selfHub.setHeartbeatInterval = function(value) {\r\n        heartbeatInterval = value;\r\n        updateHeartbeatCounters();\r\n    }\r\n\r\n    selfHub.setConnectionInvalidateInterval = function(value) {\r\n        connectionInvalidateInterval = value;\r\n        updateHeartbeatCounters();\r\n    }\r\n\r\n    selfHub.setConnectionLostTimeout = function(value) {\r\n        connectionLostTimeout = value;\r\n        updateHeartbeatCounters();\r\n    }\r\n\r\n    selfHub.VnfEndpoint = function ReliableEndpoint(eva) {\r\n        var self = this;\r\n        selfHub.ProxyEndpoint.call(self, eva);\r\n\r\n        var parentEndpoint = self.parentEndpoint;\r\n        var endpointId = _utils_random_js__WEBPACK_IMPORTED_MODULE_2__.Random.random6();\r\n\r\n        var nextSessionIndex = 1;\r\n        var timerActive = false;\r\n\r\n        var dropQueueNonEmpty = false;\r\n        var dropParentConnectionQueue = {}\r\n\r\n        function resetConnection(connection, targetEva, state) {\r\n            connection.targetEva = targetEva;\r\n            connection.sessionIndex = nextSessionIndex++;\r\n            connection.sessionId = endpointId + \"-\" + connection.sessionIndex;\r\n\r\n            connection.silenceCounter = 0;\r\n\r\n            connection.lastHeartbeatRequest = -1;\r\n\r\n            connection.lastSentMessageNumber = -1;\r\n\r\n            connection.firstMessageNumberInSendBuffer = 0;\r\n            connection.sentMessages = new _utils_cycle_buffer_js__WEBPACK_IMPORTED_MODULE_1__.CycleBuffer();\r\n\r\n            connection.firstMessageNumberInReceivedBuffer = -1;\r\n            connection.receivedMessages = new _utils_cycle_buffer_js__WEBPACK_IMPORTED_MODULE_1__.CycleBuffer();\r\n\r\n            connection.beatCloseConnection = true;\r\n\r\n            setConnectionState(connection, state);\r\n\r\n            resetTimer();\r\n        }\r\n\r\n        function parentSend(targetEva, messageJson) {\r\n            try{\r\n                var messageString = _reliable_reliable_message_serializer_js__WEBPACK_IMPORTED_MODULE_5__.ReliableMessageSerializer.serialize(messageJson);\r\n                parentEndpoint.send(targetEva, messageString);\r\n            }catch(error) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(self.eva, \"reliable-hub\", [\"Unable to send message: \", error]);\r\n            }\r\n        }\r\n\r\n        function parentOpenConnection(targetEva) {\r\n            if(parentEndpoint.isConnected(targetEva)) {\r\n                return;\r\n            }\r\n\r\n            if(!self.getConnection(targetEva)) {\r\n                return;\r\n            }\r\n\r\n            parentEndpoint.openConnection(targetEva, function(e) {\r\n                if(e.status == _global_js__WEBPACK_IMPORTED_MODULE_3__.Global.FAILED) {\r\n                    parentOpenConnection(targetEva);\r\n                }\r\n            });\r\n        }\r\n\r\n        function parentConnectionClose(targetEva) {\r\n            parentEndpoint.closeConnection(targetEva);\r\n        }\r\n\r\n        parentEndpoint.onConnectionOpen(function onConnectionOpen(targetEva) {\r\n            var connection = self.getConnection(targetEva);\r\n            if(!connection) {\r\n                connection = dropParentConnectionQueue[targetEva]\r\n            }\r\n\r\n            if(!connection) {\r\n                return;\r\n            }\r\n\r\n            sendRefreshConnectionMessage(connection);\r\n        });\r\n\r\n        parentEndpoint.onConnectionLost(function onConnectionLost(targetEva) {\r\n            parentOpenConnection(targetEva);\r\n        });\r\n\r\n\r\n        function sendHandshakeMessage(connection) {\r\n            parentSend(connection.targetEva, {type:    MESSAGE_HANDSHAKE,\r\n                                              fromSid: connection.sessionId});\r\n        }\r\n\r\n        function sendAcceptMessage(connection) {\r\n            parentSend(connection.targetEva, {type:      MESSAGE_ACCEPT,\r\n                                              fromSid:   connection.sessionId,\r\n                                              toSid:     connection.remoteSessionId});\r\n        }\r\n\r\n        function sendHeartbeatMessage(connection, gapBegin, gapEnd) {\r\n            parentSend(connection.targetEva, {type:      MESSAGE_HEARTBEAT,\r\n                                              fromSid:   connection.sessionId,\r\n                                              toSid:     connection.remoteSessionId,\r\n                                              gapBegin:  gapBegin,\r\n                                              gapEnd:    gapEnd});\r\n        }\r\n\r\n        function sendDataMessage(connection, messageIndex, message) {\r\n            parentSend(connection.targetEva, {type: MESSAGE_DATA,\r\n                                              toSid: connection.remoteSessionId,\r\n                                              messageIndex: messageIndex,\r\n                                              payload: message})\r\n        }\r\n\r\n        function sendCloseConnectionMessage(connection) {\r\n            parentSend(connection.targetEva, {type: MESSAGE_CLOSE_CONNECTION,\r\n                                              toSid: connection.remoteSessionId,\r\n                                              fromSid: connection.sessionId})\r\n        }\r\n\r\n        function sendCloseAcceptMessage(targetEva, toSid, fromSid) {\r\n            parentSend(targetEva, {type: MESSAGE_CLOSE_ACCEPT,\r\n                                   toSid: toSid,\r\n                                   fromSid: fromSid})\r\n        }\r\n\r\n        function sendRefreshConnectionMessage(connection) {\r\n            if(!parentEndpoint.isConnected(connection.targetEva)) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(instanceId, \"send-refresh-connection-message\", \"Unable to send refresh message since parent connection is closed, connection.state = \" +  connection.state);\r\n                return;\r\n            }\r\n\r\n            if(connection.state == STATE_CONNECTED) {\r\n                var gapBegin = connection.firstMessageNumberInReceivedBuffer + 1;\r\n                var gapEnd   = -1;\r\n\r\n                var receivedMessagesLength = connection.receivedMessages.length;\r\n                if(receivedMessagesLength > 0) {\r\n                    var i;\r\n\r\n                    var array = connection.receivedMessages.array;\r\n                    var beginPointer = connection.receivedMessages.beginPointer;\r\n                    var arrayLength = array.length;\r\n\r\n                    for(i = 0; i < receivedMessagesLength; i++) {\r\n                        if(array[(beginPointer + i) % arrayLength]) {\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    gapEnd = gapBegin + i;\r\n                }\r\n\r\n                sendHeartbeatMessage(connection, gapBegin, gapEnd);\r\n                return;\r\n            }\r\n\r\n            if(connection.state == STATE_ACCEPTING) {\r\n                sendAcceptMessage(connection);\r\n                return;\r\n            }\r\n\r\n            if(connection.state == STATE_HANDSHAKING) {\r\n                sendHandshakeMessage(connection);\r\n                return;\r\n            }\r\n\r\n            if(connection.state == STATE_CLOSED) {\r\n                sendCloseConnectionMessage(connection);\r\n                return;\r\n            }\r\n\r\n            if(connection.state == STATE_NO_ACTION) {\r\n                  return;\r\n            }\r\n\r\n            var instanceId = \"reliable[\" + endpointId + \":\" + eva + \"->\" + connection.targetEva + \"]\";\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(instanceId, \"send-refresh-connection-message\", \"Unexpected connection state: '\" + connection.state + \"'\");\r\n        }\r\n\r\n        function refreshConnection(connection) {\r\n\r\n            if(connection.targetEva == self.eva) {\r\n                return;\r\n            }\r\n\r\n            connection.silenceCounter++;\r\n\r\n            var invalidateConnectionCounter = connection.silenceCounter % heartbeatsToInvalidate;\r\n\r\n            var instanceId = \"reliable[\" + endpointId + \":\" + eva + \"->\" + connection.targetEva + \"]\";\r\n\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"reliable-channel-status\",\r\n              \"connection-invalidate: \" + invalidateConnectionCounter + \"/\" + heartbeatsToInvalidate + \"; \"\r\n            + \"connection-keep-alive: \" + connection.silenceCounter   + \"/\" + heartbeatsToDropConnection);\r\n\r\n\r\n\r\n            if(connection.silenceCounter >= heartbeatsToDropConnection) {\r\n                if(connection.state == STATE_ACCEPTING && connection.callback != null) {\r\n                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"reliable-channel-status\", \"fallback to handshake state\");\r\n\r\n                    resetConnection(connection, connection.targetEva, STATE_HANDSHAKING)\r\n                }else{\r\n                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"reliable-channel-status\", \"connection lost\");\r\n\r\n                    self.closeConnection(connection.targetEva);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if(invalidateConnectionCounter == 0 && connection.state != STATE_NO_ACTION) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"reliable-channel-status\", \"re-invalidate connection\");\r\n                parentConnectionClose(connection.targetEva);\r\n                parentOpenConnection(connection.targetEva);\r\n            }\r\n\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"reliable-channel-status\", \"connection refresh message sent\")\r\n            sendRefreshConnectionMessage(connection);\r\n        }\r\n\r\n        function refreshDroppedConnection(droppedConnectionEva) {\r\n            var connection = dropParentConnectionQueue[droppedConnectionEva];\r\n\r\n            connection.dropConnectionCounter--;\r\n\r\n            var newConnection = self.getConnection(droppedConnectionEva);\r\n\r\n            if(newConnection && newConnection.state != STATE_NO_ACTION) {\r\n                delete dropParentConnectionQueue[droppedConnectionEva];\r\n                return;\r\n            }\r\n\r\n            if(connection.beatCloseConnection && parentEndpoint.isConnected(droppedConnectionEva)) {\r\n                sendCloseConnectionMessage(connection);\r\n            }\r\n\r\n            if(connection.dropConnectionCounter <= 0) {\r\n                delete dropParentConnectionQueue[droppedConnectionEva];\r\n\r\n                if(!newConnection) {\r\n                    parentConnectionClose(droppedConnectionEva);\r\n                }\r\n            }\r\n        }\r\n\r\n        function onTimeEvent() {\r\n            timerActive = false;\r\n            if(self.isDestroyed()) {\r\n                return;\r\n            }\r\n\r\n            var connectionsToDeactivate = [];\r\n\r\n            var connections = self.getConnections();\r\n\r\n            for(var i = 0; i < connections.length; i++) {\r\n                refreshConnection(connections[i])\r\n            }\r\n\r\n            dropQueueNonEmpty = false;\r\n            for(var droppedConnectionEva in dropParentConnectionQueue ) {\r\n                dropQueueNonEmpty = true;\r\n                refreshDroppedConnection(droppedConnectionEva);\r\n            }\r\n\r\n            resetTimer();\r\n        }\r\n\r\n\r\n        function resetTimer() {\r\n            if(!timerActive && (dropQueueNonEmpty || self.getConnections().length > 0)) {\r\n                timerActive = true;\r\n                var nextInterval = heartbeatInterval * (1 + (Math.random() * 2 - 1) * heartbeatDeviation);\r\n                window.setTimeout(onTimeEvent, nextInterval);\r\n            }\r\n        }\r\n\r\n        var allowedMessageStates = {\r\n            \"HANDSHAKE\":         {\"NO-ACTION\": true,  \"HANDSHAKING\": true,  \"ACCEPTING\": true,  \"CONNECTED\": false, \"CLOSED\": false},\r\n            \"ACCEPT\":            {\"NO-ACTION\": false, \"HANDSHAKING\": true,  \"ACCEPTING\": true,  \"CONNECTED\": true,  \"CLOSED\": false},\r\n            \"HEARTBEAT\":         {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": true,  \"CONNECTED\": true,  \"CLOSED\": false},\r\n            \"MESSAGE\":           {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": false, \"CONNECTED\": true,  \"CLOSED\": false},\r\n            \"CLOSE-CONNECTION\":  {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": true,  \"CONNECTED\": true,  \"CLOSED\": false},\r\n            \"CLOSE-ACCEPT\":      {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": false, \"CONNECTED\": false, \"CLOSED\": true}\r\n        };\r\n\r\n        var verifyFromSid = {\r\n            \"HANDSHAKE\":         {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": true,  \"CONNECTED\": true,  \"CLOSED\": false},\r\n            \"ACCEPT\":            {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": true,  \"CONNECTED\": true,  \"CLOSED\": false},\r\n            \"HEARTBEAT\":         {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": true,  \"CONNECTED\": true,  \"CLOSED\": false},\r\n            \"MESSAGE\":           {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": false, \"CONNECTED\": false, \"CLOSED\": false},\r\n            \"CLOSE-CONNECTION\":  {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": true,  \"CONNECTED\": true,  \"CLOSED\": false},\r\n            \"CLOSE-ACCEPT\":      {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": false, \"CONNECTED\": false, \"CLOSED\": true}\r\n        };\r\n\r\n        var verifyToSid = {\r\n            \"HANDSHAKE\":         {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": false, \"CONNECTED\": false, \"CLOSED\": false},\r\n            \"ACCEPT\":            {\"NO-ACTION\": false, \"HANDSHAKING\": true,  \"ACCEPTING\": true,  \"CONNECTED\": true,  \"CLOSED\": false},\r\n            \"HEARTBEAT\":         {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": true,  \"CONNECTED\": true,  \"CLOSED\": false},\r\n            \"MESSAGE\":           {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": false, \"CONNECTED\": true,  \"CLOSED\": false},\r\n            \"CLOSE-CONNECTION\":  {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": false, \"CONNECTED\": true,  \"CLOSED\": false},\r\n            \"CLOSE-ACCEPT\":      {\"NO-ACTION\": false, \"HANDSHAKING\": false, \"ACCEPTING\": false, \"CONNECTED\": false, \"CLOSED\": true}\r\n        };\r\n\r\n        function verifyIfPhantom(connection, message) {\r\n            var messageType = message.type;\r\n            var connectionState = connection.state;\r\n\r\n            if(!allowedMessageStates[messageType][connectionState])\r\n                return \"Message type: '\" + messageType + \"' isn't allowed for channel state: '\" + connectionState + \"'\";\r\n\r\n            if(verifyFromSid[messageType][connectionState]) {\r\n                if(connection.remoteSessionId != message.fromSid)\r\n                    return \"Message fromSid isn't the same to connection.remoteSessionId,\" +\r\n                    \" for messageType: '\" + messageType + \"' and connectionState: '\"  + connectionState + \"'\";\r\n            }\r\n\r\n            if(verifyToSid[messageType][connectionState]) {\r\n                if(connection.sessionId != message.toSid)\r\n                    return \"Message toSid isn't the same to connection.sessionId,\" +\r\n                    \" for messageType: '\" + messageType + \"' and connectionState: '\"  + connectionState + \"'\";\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function setConnectionState(connection, newState) {\r\n            var instanceId = \"reliable[\" + endpointId + \":\" + eva + \"->\" + connection.targetEva + \"]\";\r\n\r\n            connection.state = newState;\r\n\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"reliable-channel-status\", \"channel state changed to: \" + connection.state);\r\n        }\r\n\r\n\r\n        function handleHandshakeMessage(event, connection, message) {\r\n            if(  connection.state == STATE_NO_ACTION\r\n              || connection.state == STATE_HANDSHAKING) {\r\n\r\n                setConnectionState(connection, STATE_ACCEPTING);\r\n                connection.remoteSessionId = message.fromSid;\r\n\r\n                sendAcceptMessage(connection);\r\n            }\r\n        }\r\n\r\n        function handleAcceptMessage(event, connection, message) {\r\n            if(  connection.state == STATE_HANDSHAKING\r\n              || connection.state == STATE_ACCEPTING) {\r\n\r\n                setConnectionState(connection, STATE_CONNECTED);\r\n                connection.remoteSessionId = message.fromSid;\r\n\r\n                sendHeartbeatMessage(connection, 0, -1);\r\n\r\n                self.__connectionOpened(connection);\r\n            }\r\n        }\r\n\r\n        function handleHeartbeatMessage(event, connection, message) {\r\n            if(connection.state == STATE_CONNECTED) {\r\n                var prevHeartBeatRequest = connection.lastHeartbeatRequest;\r\n                connection.lastHeartbeatRequest = message.gapBegin;\r\n\r\n                // performance optimization - to not flood the network\r\n                // to avoid double sending of message, responding to gap only after second heartbeat\r\n                // due to network latencies heartbeat can be out-dated, while message is delivered\r\n                if(message.gapEnd == -1 && prevHeartBeatRequest != message.gapBegin) {\r\n                    return;\r\n                }\r\n\r\n                // removing messages before gapBegin in sent buffer\r\n                var sentMessages = connection.sentMessages;\r\n                if(connection.firstMessageNumberInSendBuffer < message.gapBegin) {\r\n                    sentMessages.removeFirst(message.gapBegin - connection.firstMessageNumberInSendBuffer);\r\n                    connection.firstMessageNumberInSendBuffer = message.gapBegin;\r\n                }\r\n\r\n                var array = sentMessages.array;\r\n                for(var i = 0; i < sentMessages.length; i++) {\r\n                    if(message.gapEnd != -1 && message.gapEnd < i + message.gapBegin) {\r\n                        break;\r\n                    }\r\n\r\n                    var gapMessage = array[(i + sentMessages.beginPointer) % array.length];\r\n\r\n                    if(gapMessage) {\r\n                        sendDataMessage(connection, i + message.gapBegin, gapMessage);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(connection.state == STATE_ACCEPTING) {\r\n                setConnectionState(connection, STATE_CONNECTED);\r\n                connection.remoteSessionId = message.fromSid;\r\n\r\n                self.__connectionOpened(connection)\r\n\r\n                return;\r\n            }\r\n        }\r\n\r\n        function handleDataMessage(event, connection, message) {\r\n            var receivedMessages = connection.receivedMessages;\r\n\r\n            if(message.messageIndex == connection.firstMessageNumberInReceivedBuffer + 1) {\r\n                try {\r\n                    self.onMessage && self.onMessage({\r\n                                            message: message.payload,\r\n                                            sourceEva: event.sourceEva,\r\n                                            endpoint: self\r\n                    });\r\n                }catch(e) {\r\n                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(self.eva, \"reliable-hub\", [\"Error in onMessage handler: \", e]);\r\n                }\r\n            }else {\r\n                if(message.messageIndex > connection.firstMessageNumberInReceivedBuffer) {\r\n                    receivedMessages.setValue(message.messageIndex - connection.firstMessageNumberInReceivedBuffer - 2, message);\r\n                }\r\n\r\n                return;\r\n            }\r\n\r\n            var processedMessages = 1;\r\n\r\n            var receivedMessagesLength = receivedMessages.length;\r\n            var arrayLength = receivedMessages.array.length;\r\n\r\n            for(var i = 0; i < receivedMessagesLength; i++) {\r\n                var arrayIndex = receivedMessages.beginPointer + i;\r\n                arrayIndex %= arrayLength;\r\n\r\n                var message = receivedMessages.array[arrayIndex];\r\n                if(!message) break;\r\n\r\n                processedMessages++;\r\n                try {\r\n                    self.onMessage&& self.onMessage({\r\n                        message: message.payload,\r\n                        sourceEva: event.sourceEva,\r\n                        endpoint: self\r\n                    });\r\n                }catch(e) {\r\n                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(self.eva, \"reliable-hub\", [\"Error in onMessage handler: \", e]);\r\n                }\r\n            }\r\n\r\n            connection.firstMessageNumberInReceivedBuffer += processedMessages;\r\n            receivedMessages.removeFirst(processedMessages);\r\n        }\r\n\r\n        function handleCloseMessage(event, connection, message) {\r\n            if(connection.state == STATE_CONNECTED) {\r\n                connection.beatCloseConnection = false;\r\n                self.closeConnection(connection.targetEva);\r\n                return;\r\n            }\r\n        }\r\n\r\n        function handleCloseAcceptMessage(event, connection, message) {\r\n            connection.beatCloseConnection = false;\r\n        }\r\n\r\n        var handlers = {\r\n            \"HANDSHAKE\": handleHandshakeMessage,\r\n            \"ACCEPT\":    handleAcceptMessage,\r\n            \"HEARTBEAT\": handleHeartbeatMessage,\r\n            \"MESSAGE\":   handleDataMessage,\r\n\r\n            \"CLOSE-CONNECTION\": handleCloseMessage,\r\n            \"CLOSE-ACCEPT\": handleCloseAcceptMessage\r\n        }\r\n\r\n\r\n        this.setEndpointId = function(value) {\r\n            endpointId = value;\r\n        }\r\n\r\n        parentEndpoint.onMessage = function handleMessage(event) {\r\n            if(self.isDestroyed()) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(\"reliable-hub\", \"ReliableHub: Unable to handle message, because endpoint is destroyed\")\r\n            }\r\n\r\n            //Log.verbose(self.eva, \"reliable-hub\", \"onMessage: \" + JSON.stringify(event));\r\n\r\n            var message = _reliable_reliable_message_serializer_js__WEBPACK_IMPORTED_MODULE_5__.ReliableMessageSerializer.deserialize(event.message);\r\n\r\n            if(message.type == MESSAGE_CLOSE_CONNECTION) {\r\n                sendCloseAcceptMessage(event.sourceEva, message.fromSid, message.toSid);\r\n            }\r\n\r\n            var handler = handlers[message.type];\r\n\r\n            if(!handler) {\r\n                throw new Error(\"ReliableHub: Unknown message type received: \" + message.type);\r\n            }\r\n\r\n            var connection;\r\n            if(message.type == MESSAGE_CLOSE_ACCEPT && dropParentConnectionQueue[event.sourceEva]) {\r\n                connection = dropParentConnectionQueue[event.sourceEva];\r\n            }else{\r\n                connection = self.__lazyNewConnection(event.sourceEva);\r\n                if(!connection.state) {\r\n                    resetConnection(connection, event.sourceEva, STATE_NO_ACTION);\r\n                }\r\n            }\r\n\r\n            var phantomError = verifyIfPhantom(connection, message);\r\n            if(phantomError) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(\"reliable-hub\", [\"Phantom detected: \" + phantomError,  event, connection]);\r\n                return;\r\n            }\r\n\r\n            connection.silenceCounter = 0;\r\n\r\n            handler(event, connection, message);\r\n        }\r\n\r\n        self.__doOpenConnection = function(connection) {\r\n            resetConnection(connection, connection.targetEva, STATE_HANDSHAKING);\r\n            parentOpenConnection(connection.targetEva);\r\n\r\n            if(parentEndpoint.isConnected(connection.targetEva)) {\r\n                sendRefreshConnectionMessage(connection);\r\n            }\r\n        }\r\n\r\n        self.__doOpenConnectionRetryLoop = function(connection) {}\r\n\r\n        self.__doSend = function(connection, message) {\r\n            connection.lastSentMessageNumber++;\r\n            connection.sentMessages.push(message);\r\n\r\n            sendDataMessage(connection, connection.lastSentMessageNumber, message)\r\n        }\r\n\r\n        var __superDoReleaseConnection = self.__doReleaseConnection;\r\n        self.__doReleaseConnection = function(connection) {\r\n            if(connection.state == STATE_NO_ACTION && !dropParentConnectionQueue[connection.targetEva] && !self.getConnection(connection.targetEva)) {\r\n                parentConnectionClose(connection.targetEva);\r\n            }\r\n\r\n            if(connection.state == STATE_NO_ACTION) {\r\n                setConnectionState(connection, STATE_CLOSED);\r\n                return;\r\n            }\r\n\r\n            if(connection.beatCloseConnection) {\r\n                sendCloseConnectionMessage(connection);\r\n            }\r\n            setConnectionState(connection, STATE_CLOSED);\r\n\r\n            dropQueueNonEmpty = true;\r\n            connection.dropConnectionCounter = heartbeatsToDropConnection;\r\n            dropParentConnectionQueue[connection.targetEva] = connection;\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/channel/reliable-hub.js?");

/***/ }),

/***/ "./src/vnf/channel/reliable-rtc-hub.js":
/*!*********************************************!*\
  !*** ./src/vnf/channel/reliable-rtc-hub.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ReliableRtcHub\": () => (/* binding */ ReliableRtcHub)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _rtc_hub_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rtc-hub.js */ \"./src/vnf/channel/rtc-hub.js\");\n/* harmony import */ var _reliable_hub_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reliable-hub.js */ \"./src/vnf/channel/reliable-hub.js\");\n\r\n\r\n\r\n\r\n\r\nfunction ReliableRtcHub(hub) {\r\n    var selfHub = this;\r\n\r\n    var rtcHub = new _rtc_hub_js__WEBPACK_IMPORTED_MODULE_1__.RtcHub(hub);\r\n    _reliable_hub_js__WEBPACK_IMPORTED_MODULE_2__.ReliableHub.call(selfHub, rtcHub);\r\n};\n\n//# sourceURL=webpack://Vnf/./src/vnf/channel/reliable-rtc-hub.js?");

/***/ }),

/***/ "./src/vnf/channel/reliable/reliable-message-serializer.js":
/*!*****************************************************************!*\
  !*** ./src/vnf/channel/reliable/reliable-message-serializer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ReliableMessageSerializer\": () => (/* binding */ ReliableMessageSerializer)\n/* harmony export */ });\nfunction splitToArray(stringValue, number) {\r\n    var result = [];\r\n\r\n    var prevSpaceIndex = -1;\r\n\r\n    for(var i  = 0; i < number - 1; i++) {\r\n        var spaceIndex = stringValue.indexOf(' ', prevSpaceIndex + 1);\r\n\r\n        if(spaceIndex == -1) {\r\n            throw new Error(\"Unable split string into \" + number + \" parts. String value is: '\" + stringValue + \"'\");\r\n        }\r\n\r\n        result[i] = stringValue.substr(prevSpaceIndex  + 1, spaceIndex - prevSpaceIndex  - 1);\r\n\r\n        prevSpaceIndex = spaceIndex;\r\n    }\r\n\r\n    result[result.length] = stringValue.substr(spaceIndex+1);\r\n\r\n    return result;\r\n}\r\n\r\nclass ReliableMessageSerializer {\r\n    static serialize (message) {\r\n        if(message.type == 'MESSAGE') {\r\n            return 'MESSAGE ' + message.toSid + ' ' + message.messageIndex + ' ' + message.payload;\r\n        }\r\n\r\n        if(message.type == 'HEARTBEAT') {\r\n            return 'HEARTBEAT ' + message.toSid + ' ' + message.fromSid + ' ' + message.gapBegin + ' ' + message.gapEnd;\r\n        }\r\n\r\n        if(message.type == 'HANDSHAKE') {\r\n            return 'HANDSHAKE ' + message.fromSid;\r\n        }\r\n\r\n        if(message.type == 'ACCEPT') {\r\n            return 'ACCEPT ' + message.toSid + ' ' + message.fromSid;\r\n        }\r\n\r\n        if(message.type == 'CLOSE-CONNECTION') {\r\n            return 'CLOSE-CONNECTION ' + message.toSid + ' ' + message.fromSid;\r\n        }\r\n\r\n        if(message.type == 'CLOSE-ACCEPT') {\r\n            return 'CLOSE-ACCEPT ' + message.toSid + ' ' + message.fromSid;\r\n        }\r\n\r\n        throw new Error(\"Unexpected type: '\" + message.type + \"' to serialize\");\r\n    }\r\n\r\n    static deserialize (stringValue) {\r\n        var messageTypeIndex = stringValue.indexOf(' ');\r\n        var type = stringValue.substr(0, messageTypeIndex);\r\n\r\n        var remainString = stringValue.substr(messageTypeIndex + 1);\r\n\r\n        if(type == 'MESSAGE') {\r\n            var messageValues = splitToArray(remainString, 3);\r\n\r\n            return {\r\n                type: 'MESSAGE',\r\n                toSid:         messageValues[0],\r\n                messageIndex:  messageValues[1] - 0,\r\n                payload:       messageValues[2]\r\n            };\r\n        }\r\n\r\n        if(type == 'HEARTBEAT') {\r\n            var messageValues = splitToArray(remainString, 4);\r\n\r\n            return {\r\n                type: 'HEARTBEAT',\r\n                toSid:    messageValues[0],\r\n                fromSid:  messageValues[1],\r\n                gapBegin: messageValues[2] - 0,\r\n                gapEnd:   messageValues[3] - 0\r\n            };\r\n        }\r\n\r\n        if(type == 'HANDSHAKE') {\r\n            return {\r\n                type: 'HANDSHAKE',\r\n                fromSid: remainString\r\n            };\r\n        }\r\n\r\n        if(type == 'ACCEPT') {\r\n            var messageValues = splitToArray(remainString, 2);\r\n\r\n            return {\r\n                type: 'ACCEPT',\r\n                toSid:   messageValues[0],\r\n                fromSid: messageValues[1]\r\n            };\r\n        }\r\n\r\n        if(type == 'CLOSE-CONNECTION') {\r\n            var messageValues = splitToArray(remainString, 2);\r\n\r\n            return {\r\n                type: 'CLOSE-CONNECTION',\r\n                toSid:    messageValues[0],\r\n                fromSid:  messageValues[1]\r\n            };\r\n        }\r\n\r\n        if(type == 'CLOSE-ACCEPT') {\r\n            var messageValues = splitToArray(remainString, 2);\r\n\r\n            return {\r\n                type: 'CLOSE-ACCEPT',\r\n                toSid:    messageValues[0],\r\n                fromSid:  messageValues[1]\r\n            };\r\n        }\r\n\r\n        throw new Error(\"Unexpected type: '\" + type + \"' to deserialize\");\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/channel/reliable/reliable-message-serializer.js?");

/***/ }),

/***/ "./src/vnf/channel/rtc-hub.js":
/*!************************************!*\
  !*** ./src/vnf/channel/rtc-hub.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RtcHub\": () => (/* binding */ RtcHub)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _utils_xtimeout_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/xtimeout.js */ \"./src/utils/xtimeout.js\");\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../global.js */ \"./src/vnf/global.js\");\n/* harmony import */ var _base_vnf_proxy_hub_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base/vnf-proxy-hub.js */ \"./src/vnf/channel/base/vnf-proxy-hub.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nwindow.vnfRtcServers = undefined;\r\n\r\n/*window.vnfRtcServers = {\r\n    iceServers: [\r\n        //{url: \"stun:23.21.150.121\"},\r\n        //{url: \"stun:stun.1.google.com:19302\"},\r\n        {urls: \"stun:127.0.0.1\"}\r\n    ]\r\n};*/\r\n\r\n\r\nvar PACKET_CHUNK_LENGTH = 64*1024;\r\n\r\nfunction printStatuses(connection){\r\n    return JSON.stringify({\r\n        signalingState:     connection.signalingState,\r\n        iceConnectionState: connection.iceConnectionState,\r\n        iceGatheringState:  connection.iceGatheringState\r\n    });\r\n}\r\n\r\nfunction logErrorCallback(instanceId){\r\n    var stacktrace = Error().stack;\r\n    return function logError(e) {\r\n        window.RtcDebugLastError = e;\r\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(instanceId, \"webrtc-logerror\", e + \" see RtcDebugLastError for details\\n\" + stacktrace);\r\n    }\r\n\r\n}\r\n\r\nfunction logSuccess(e){}\r\n\r\nvar connectionNextId = 0;\r\n\r\nfunction VnfRtcConnection(connectionId){\r\n\r\n    var RTCPeerConnection     = window.RTCPeerConnection     || window.mozRTCPeerConnection     || window.webkitRTCPeerConnection;\r\n    var RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription;\r\n    var RTCIceCandidate       = window.RTCIceCandidate       || window.mozRTCIceCandidate       || window.webkitRTCIceCandidate;\r\n\r\n\r\n    var self = this;\r\n    var instanceId = \"rtc[connection-\" + connectionId + \"]\";\r\n\r\n    var connection = null;\r\n    var channel = null;\r\n\r\n    var ice = null;\r\n\r\n    var destroyed = false;\r\n\r\n    var onIceCandidatesCallback = null;\r\n\r\n    var onChannelOpenedCallback = null;\r\n    var onChannelMessageCallback = null;\r\n    var onChannelClosedCallback = null;\r\n\r\n    self.createDate = new Date().getTime();\r\n\r\n    self.startCaller = function(callback) {\r\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"webrtc-connecting\", \"startCaller\");\r\n\r\n        self.isCaller = true;\r\n        onIceCandidatesCallback = callback;\r\n\r\n        createRtcConnection();\r\n\r\n        handleNewChannel(connection.createDataChannel(\"data\"));\r\n\r\n        connection.createOffer(onGotDescription, logErrorCallback(instanceId));\r\n    }\r\n\r\n    self.startCallee = function(ice, callback) {\r\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"webrtc-connecting\", \"startCallee: \" + JSON.stringify(ice));\r\n\r\n        self.isCaller = false;\r\n        onIceCandidatesCallback = callback;\r\n\r\n        createRtcConnection();\r\n\r\n        connection.setRemoteDescription(new RTCSessionDescription(ice.sdp), logSuccess, logErrorCallback(instanceId));\r\n\r\n        connection.createAnswer(function(desc){\r\n            for(var i = 0; i < ice.candidate.length; i++) {\r\n                connection.addIceCandidate(new RTCIceCandidate(ice.candidate[i]));\r\n            }\r\n\r\n            onGotDescription(desc);\r\n        }, logErrorCallback(instanceId));\r\n\r\n        connection.ondatachannel = function(evt){\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"webrtc-connecting\", \"ondatachannel: \" + JSON.stringify(evt));\r\n            handleNewChannel(evt.channel);\r\n        }\r\n    }\r\n\r\n    self.acceptCalleeResponse = function(ice) {\r\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"webrtc-connecting\", \"acceptCalleeResponse: \" + JSON.stringify(ice));\r\n\r\n        connection.setRemoteDescription(new RTCSessionDescription(ice.sdp), logSuccess, logErrorCallback(instanceId));\r\n\r\n        for(var i = 0; i < ice.candidate.length; i++) {\r\n            connection.addIceCandidate(new RTCIceCandidate(ice.candidate[i]));\r\n        }\r\n    }\r\n\r\n    self.send = function(message) {\r\n        channel.send(message);\r\n    }\r\n\r\n    self.getRtcConnection = function() {\r\n        return connection;\r\n    }\r\n\r\n    self.destroy = function() {\r\n        destroyed = true;\r\n\r\n        if(channel) {\r\n            channel.onopen = function(){};\r\n            channel.onmessage = function(){};\r\n            channel.onclose = function(){};\r\n        }\r\n\r\n        if(connection) {\r\n            connection.ondatachannel = function(){};\r\n            connection.onsignalingstatechange = function(){};\r\n            connection.onconnectionstatechange = function(){};\r\n            connection.oniceconnectionstatechange = function(){};\r\n        }\r\n\r\n        // closing rtc connection will increase sending signal to other side to 5 seconds.\r\n        if(connection) window.setTimeout(destroyRtcConnection, 1000);\r\n        try{\r\n            if(channel) {\r\n                channel.close();\r\n                channel = null;\r\n            }\r\n        }catch(e) {\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(instanceId, \"web-rtc\", [\"Unable to destroy Rtc connection\", e]);\r\n        }\r\n\r\n        function destroyRtcConnection() {\r\n            try{\r\n                if(connection) connection.close();\r\n                connection = null;\r\n            }catch(e) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(instanceId, \"web-rtc\", [\"Unable to destroy Rtc connection\", e]);\r\n            }\r\n        }\r\n    }\r\n\r\n    self.onChannelOpened = function(callback) {\r\n        onChannelOpenedCallback = callback;\r\n    }\r\n\r\n    self.onChannelMessage = function(callback) {\r\n        onChannelMessageCallback = callback;\r\n    }\r\n\r\n    self.onChannelClosed = function(callback) {\r\n        onChannelClosedCallback = callback;\r\n    }\r\n\r\n\r\n    function handleNewChannel(channelArgument) {\r\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"webrtc-connecting\", \"onChannelCreated: \" + channelArgument);\r\n        channel = channelArgument;\r\n\r\n        channel.onopen = function(event) {\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"webrtc-connecting\", \"onChannelOpened: \" + event);\r\n\r\n            if(onChannelOpenedCallback) {\r\n                onChannelOpenedCallback();\r\n            }\r\n        }\r\n\r\n        channel.onmessage = function(e) {\r\n            try{\r\n                onChannelMessageCallback(e.data);\r\n            }catch(e) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(instanceId, \"webrtc-onmessage\", [\"Error in onmessage handler\", e]);\r\n            }\r\n        }\r\n\r\n        channel.onclose = function(evt) {\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"webrtc-onclose\", \"\\n\" + printStatuses(evt.target));\r\n            if(!destroyed) {\r\n                self.destroy();\r\n                onChannelClosedCallback();\r\n            }\r\n        }\r\n\r\n        if(channel.readyState == \"open\" && onChannelOpenedCallback) {\r\n            onChannelOpenedCallback();\r\n        }\r\n    }\r\n\r\n    function createRtcConnection() {\r\n        connection = new RTCPeerConnection(vnfRtcServers);\r\n\r\n        ice = {candidate: []};\r\n\r\n        var sendCandidates = (0,_utils_xtimeout_js__WEBPACK_IMPORTED_MODULE_1__.xTimeout)(Timeouts.iceSendTimeout, function sendCandidates() {\r\n            if(destroyed) return;\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"webrtc-ice-gathered\", \"\\n\" + JSON.stringify(ice));\r\n            onIceCandidatesCallback(ice);\r\n        });\r\n\r\n        connection.onsignalingstatechange = function(evt){\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"webrtc-onsignalingstatechange\", \"\\n\" + printStatuses(evt.target));\r\n\r\n        };\r\n\r\n        connection.onconnectionstatechange = function(evt) {\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"webrtc-onconnectionstatechange\", \"\\n\" + printStatuses(evt.target) + \", destroyed: \" + destroyed);\r\n        }\r\n\r\n        connection.oniceconnectionstatechange = function(evt){\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"webrtc-oniceconnectionstatechange\", \"\\n\" + printStatuses(evt.target) + \", destroyed: \" + destroyed);\r\n            if(evt.target.iceConnectionState == \"disconnected\" && !destroyed) {\r\n                destroyed = true;\r\n                onChannelClosedCallback();\r\n            }\r\n        };\r\n\r\n        connection.onicecandidate = function(evt){\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"webrtc-connecting\", \"onicecandidate: \" + JSON.stringify(evt.candidate));\r\n\r\n            if(evt.candidate != null) ice.candidate.push(evt.candidate);\r\n\r\n            sendCandidates.extend(Timeouts.iceSendTimeout);\r\n\r\n            if(evt.candidate == null) {\r\n                sendCandidates.trigger()\r\n            }\r\n        }\r\n    }\r\n\r\n    function onGotDescription(desc) {\r\n        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(instanceId, \"webrtc-connecting\", \"onGotDescription: \" + JSON.stringify(desc));\r\n\r\n        connection.setLocalDescription(desc);\r\n        ice.sdp = desc;\r\n    }\r\n}\r\n\r\nfunction RtcHub(signalingHub){\r\n    var selfHub = this;\r\n    _base_vnf_proxy_hub_js__WEBPACK_IMPORTED_MODULE_3__.ProxyHub.call(selfHub, signalingHub);\r\n\r\n    selfHub.setEstablishConnectionTimeout(1500);\r\n\r\n    selfHub.VnfEndpoint = function RTCEndpoint(selfEva) {\r\n        var self = this;\r\n        selfHub.ProxyEndpoint.call(self, selfEva);\r\n\r\n        var signalingEndpoint = self.parentEndpoint;\r\n\r\n        function createVnfRtcConnection(connection) {\r\n            var connectionIndex = connectionNextId++;\r\n            var vnfRtcConnection = new VnfRtcConnection(connectionIndex + \": \" + selfEva + \"->\" + connection.targetEva )\r\n\r\n            vnfRtcConnection.onChannelOpened(function() {\r\n                if(self.isDestroyed()) {\r\n                    vnfRtcConnection.destroy();\r\n\r\n                    return;\r\n                }\r\n\r\n                self.__connectionOpened(connection);\r\n            });\r\n\r\n            vnfRtcConnection.onChannelMessage(function(message) {\r\n                if(!connection.isConnected || connection.isDestroyed) {\r\n                    return;\r\n                }\r\n\r\n                try {\r\n                    self.onMessage && self.onMessage({\r\n                        message: message,\r\n                        sourceEva: connection.targetEva,\r\n                        endpoint:  self\r\n                    });\r\n                }catch(e) {\r\n                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(\"rtc[\" + selfEva + \"->\" + event.sourceEva + \"]\", \"web-rtc\", [\"Error in onMessage handler \", e]);\r\n                }\r\n            })\r\n\r\n            vnfRtcConnection.onChannelClosed(function vnfChannelClosedCallback(){\r\n                self.__rejectConnection(connection);\r\n            });\r\n\r\n            return vnfRtcConnection;\r\n        }\r\n\r\n        signalingEndpoint.onMessage = function(event) {\r\n            var message = JSON.parse(event.message);\r\n            if(message.type == \"rtc-connection\") {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(\"rtc[\" + selfEva + \"->\" + event.sourceEva + \"]\", \"webrtc-connecting\", \"handling-signal-message: \" + JSON.stringify(event));\r\n\r\n                var targetEva = event.sourceEva;\r\n\r\n                var connection = self.__lazyNewConnection(targetEva);\r\n                var existentVnfRtcConnection = connection.vnfRtcConnection;\r\n\r\n                if(message.requestForNewConnection) {\r\n                    if(existentVnfRtcConnection && existentVnfRtcConnection.isCaller && message.connectionCreateDate < existentVnfRtcConnection.createDate) {\r\n                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(\"rtc[\" + selfEva + \"->...]\", \"webrtc-connecting\", \"ignore-action/connection-expired:\" + JSON.stringify(event));\r\n                        return;\r\n                    }\r\n\r\n                    connection.vnfRtcConnection = createVnfRtcConnection(connection);\r\n                    connection.vnfRtcConnection.startCallee(message.ice, function(ice){\r\n                        var message =  {type: \"rtc-connection\",\r\n                                        requestForNewConnection: false,\r\n                                        ice: ice,\r\n                                        connectionCreateDate: connection.vnfRtcConnection.createDate};\r\n\r\n                        try{\r\n                            signalingEndpoint.send(connection.targetEva, JSON.stringify(message));\r\n                        }catch(e) {\r\n                            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(\"rtc[\" + selfEva + \"]\", \"web-rtc\", [\"Unable to send accept message via signaling endpoint\", e]);\r\n                        }\r\n                    });\r\n\r\n                    if(existentVnfRtcConnection) {\r\n                        existentVnfRtcConnection.destroy();\r\n                    }\r\n                }else{\r\n                    if(existentVnfRtcConnection.isCaller) {\r\n                        existentVnfRtcConnection.acceptCalleeResponse(message.ice);\r\n                    }\r\n                }\r\n           }\r\n        }\r\n\r\n        self.__doOpenConnection_NextTry = function(connection) {\r\n            signalingEndpoint.openConnection(connection.targetEva, function(event) {\r\n                if(connection.isConnected || connection.isDestroyed) {\r\n                    return;\r\n                }\r\n\r\n                if(event.status  == _global_js__WEBPACK_IMPORTED_MODULE_2__.Global.FAILED) {\r\n                    self.__connectionNextTryFailed(connection);\r\n                    return;\r\n                }\r\n\r\n                connection.vnfRtcConnection = createVnfRtcConnection(connection);\r\n                connection.vnfRtcConnection.startCaller(function(ice){\r\n\r\n                    var message =  {type: \"rtc-connection\",\r\n                                    requestForNewConnection: true,\r\n                                    ice: ice,\r\n                                    connectionCreateDate: connection.vnfRtcConnection.createDate};\r\n                    try {\r\n                        signalingEndpoint.send(connection.targetEva, JSON.stringify(message));\r\n                    }catch(e) {\r\n                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(\"rtc[\" + selfEva + \"]\", \"web-rtc\", [\"Unable to send handshake message via signaling endpoint\", e]);\r\n                    }\r\n                });\r\n            })\r\n        }\r\n\r\n        self.__doOpenConnection_CleanBeforeNextTry = function(connection) {\r\n            if(connection.vnfRtcConnection) {\r\n                connection.vnfRtcConnection.destroy();\r\n            }\r\n        }\r\n\r\n        var __superDoReleaseConnection = self.__doReleaseConnection;\r\n        self.__doReleaseConnection = function(connection) {\r\n            self.__doOpenConnection_CleanBeforeNextTry(connection);\r\n\r\n            __superDoReleaseConnection(connection);\r\n        }\r\n\r\n        self.getRtcConnection = function(eva) {\r\n            return self.getConnection(eva).vnfRtcConnection.getRtcConnection();\r\n        }\r\n\r\n        self.__doSend = function(connection, message) {\r\n            try{\r\n                connection.vnfRtcConnection.send(message);\r\n            }catch(e) {\r\n                if(!connection.isConnected && !connection.isDestroyed()) {\r\n                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(\"rtc[\" + selfEva + \"]\", \"web-rtc\", [\"Unable to send message via RTC\"]);\r\n                }\r\n\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(\"rtc[\" + selfEva + \"]\", \"web-rtc\", [\"Unable to send message via RTC\", e]);\r\n           }\r\n        }\r\n    };\r\n};\r\n\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/channel/rtc-hub.js?");

/***/ }),

/***/ "./src/vnf/channel/unreliable-hub.js":
/*!*******************************************!*\
  !*** ./src/vnf/channel/unreliable-hub.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UnreliableHub\": () => (/* binding */ UnreliableHub)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../global.js */ \"./src/vnf/global.js\");\n/* harmony import */ var _base_vnf_proxy_hub_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base/vnf-proxy-hub.js */ \"./src/vnf/channel/base/vnf-proxy-hub.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nfunction UnreliableHub(hub) {\r\n    var selfHub = this;\r\n\r\n    _base_vnf_proxy_hub_js__WEBPACK_IMPORTED_MODULE_2__.ProxyHub.call(selfHub, hub);\r\n\r\n    var blockedChannels = {};\r\n\r\n    selfHub.VnfEndpoint = function UnreliableEndpoint(selfEva) {\r\n        var self = this;\r\n        selfHub.ProxyEndpoint.call(self, selfEva);\r\n\r\n        self.parentEndpoint.onMessage = function(event) {\r\n            self.__acceptConnection(event.sourceEva)\r\n\r\n            try{\r\n                self.onMessage && self.onMessage({\r\n                    message:   event.message,\r\n                    sourceEva: event.sourceEva,\r\n                    endpoint:   self\r\n                });\r\n            }catch(e) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(\"unreliable-hub\", [\"Error in onMessage handler: \", e]);\r\n            }\r\n        }\r\n\r\n        self.__doOpenConnection = function(connection) {\r\n            self.parentEndpoint.openConnection(connection.targetEva, function(event) {\r\n                if(event.status  == _global_js__WEBPACK_IMPORTED_MODULE_1__.Global.FAILED) {\r\n                    self.__connectionOpenFailed(connection);\r\n                }else{\r\n                    self.__connectionOpened(connection)\r\n                }\r\n            })\r\n        }\r\n\r\n        self.__doSend = function(connection, message) {\r\n            if(blockedChannels[self.eva] && blockedChannels[self.eva][connection.targetEva]) {\r\n                return;\r\n            }\r\n\r\n            self.parentEndpoint.send(connection.targetEva, message);\r\n        }\r\n\r\n        self.parentEndpoint.onConnectionLost(function(targetEva){\r\n            self.closeConnection(targetEva);\r\n        });\r\n    }\r\n\r\n    selfHub.blockChannel = function(fromEva1, toEva2) {\r\n        if(!blockedChannels[fromEva1]){\r\n            blockedChannels[fromEva1] = {};\r\n        }\r\n\r\n        blockedChannels[fromEva1][toEva2] = true;\r\n    }\r\n\r\n    selfHub.unblockChannel = function(fromEva1, toEva2) {\r\n        if(blockedChannels[fromEva1]){\r\n            blockedChannels[fromEva1][toEva2] = false;\r\n        }\r\n    }\r\n}\n\n//# sourceURL=webpack://Vnf/./src/vnf/channel/unreliable-hub.js?");

/***/ }),

/***/ "./src/vnf/channel/websocket-hub.js":
/*!******************************************!*\
  !*** ./src/vnf/channel/websocket-hub.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebSocketHub\": () => (/* binding */ WebSocketHub)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../global.js */ \"./src/vnf/global.js\");\n/* harmony import */ var _websocket_websocket_rpc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../websocket/websocket-rpc.js */ \"./src/vnf/websocket/websocket-rpc.js\");\n/* harmony import */ var _base_vnf_hub_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base/vnf-hub.js */ \"./src/vnf/channel/base/vnf-hub.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction WebSocketHub(webSocketFactory){\r\n    var selfHub = this;\r\n\r\n    _base_vnf_hub_js__WEBPACK_IMPORTED_MODULE_3__.VnfHub.call(selfHub);\r\n\r\n    var rpcBusyTimerInterval = null;\r\n    var rpcIdleTimerInterval = null;\r\n    var rpcLoginRecreateInterval = null;\r\n\r\n    this.setRpcBusyTimerInterval = function(value) {\r\n        rpcBusyTimerInterval = value;\r\n    }\r\n\r\n    this.setRpcIdleTimerInterval = function(value) {\r\n        rpcIdleTimerInterval = value;\r\n    }\r\n\r\n    this.setRpcLoginRecreateInterval = function(value) {\r\n        rpcLoginRecreateInterval = value;\r\n    }\r\n\r\n    selfHub.VnfEndpoint = function WebSocketEndpoint(selfEva) {\r\n        var self = this;\r\n        selfHub.BaseEndPoint.call(this, selfEva);\r\n\r\n        var webSocketRpc = new _websocket_websocket_rpc_js__WEBPACK_IMPORTED_MODULE_2__.WebSocketRpc(selfEva, webSocketFactory);\r\n        webSocketRpc.allocateUsage();\r\n\r\n        if(rpcBusyTimerInterval != null) webSocketRpc.setBusyTimerInterval(rpcBusyTimerInterval);\r\n        if(rpcIdleTimerInterval != null) webSocketRpc.setIdleTimerInterval(rpcIdleTimerInterval);\r\n        if(rpcLoginRecreateInterval != null) webSocketRpc.setLoginRecreateInterval(rpcLoginRecreateInterval);\r\n\r\n        self.__doOpenConnection_NextTry = function(connection) {\r\n            connection.rpcInvokeFuture = webSocketRpc.invokeFuture(\"SEND_TO_ENDPOINT\",  connection.targetEva + \"\\nHANDSHAKE\", {retryResend: true});\r\n\r\n            connection.rpcInvokeFuture.promise.then(function(e) {\r\n                if(e.data) {\r\n                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(\"websocket-hub\", \"SEND_TO_ENDPOINT HANDSHAKE not delivered: \" + e.data);\r\n                    self.__connectionNextTryFailed(connection);\r\n                }\r\n            })\r\n            .catch((e) => {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(\"websocket-hub\", [\"SEND_TO_ENDPOINT HANDSHAKE not delivered: \", e]);\r\n                self.__connectionNextTryFailed(connection);\r\n            });\r\n        }\r\n\r\n        self.__doOpenConnection_CleanBeforeNextTry = function(connection) {\r\n            if(connection.rpcInvokeFuture) {\r\n                connection.rpcInvokeFuture.cancel();\r\n            }\r\n        }\r\n\r\n        self.__doReleaseConnection = function(connection) {\r\n            self.__doOpenConnection_CleanBeforeNextTry(connection);\r\n\r\n            if(!connection.handlingCloseEvent) {\r\n                webSocketRpc.invoke(\"SEND_TO_ENDPOINT\",  connection.targetEva + \"\\nCLOSE-CONNECTION\", {retryResend: true})\r\n                .catch((e) => _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(\"websocket-hub\", \"SEND_TO_ENDPOINT CLOSE-CONNECTION not delivered: \" + e));\r\n            }\r\n        };\r\n\r\n        function handleHandshakeMessage(sourceEva, messageType, body) {\r\n            if(self.isDestroyed()) return;\r\n\r\n            webSocketRpc.invoke(\"SEND_TO_ENDPOINT\",  sourceEva + \"\\nACCEPT\", {retryResend: true})\r\n            .catch((e) => _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(\"websocket-hub\", \"SEND_TO_ENDPOINT ACCEPT not delivered: \" + e));\r\n\r\n            self.__acceptConnection(sourceEva);\r\n        }\r\n\r\n        function handleAcceptMessage(sourceEva, messageType, body) {\r\n            var  connection  = self.getConnection(sourceEva);\r\n\r\n            if(!connection) return;\r\n\r\n            self.__connectionOpened(connection);\r\n        }\r\n\r\n        function handleMessage(sourceEva, messageType, body) {\r\n            if(!self.isConnected(sourceEva)) {\r\n                return false;\r\n            }\r\n\r\n            try{\r\n                self.onMessage && self.onMessage({sourceEva: sourceEva,\r\n                                                  message:   body,\r\n                                                  endpoint:  self});\r\n            }catch(e) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(\"websocket-hub\", [\"Error in onMessage handler: \", e]);\r\n            }\r\n        }\r\n\r\n        function handleCloseConnection(sourceEva, messageType, body) {\r\n            var connection = self.getConnection(sourceEva);\r\n            if(connection) connection.handlingCloseEvent = true;\r\n            self.closeConnection(sourceEva);\r\n        }\r\n\r\n        var messageHandlers = {\r\n            \"HANDSHAKE\":        handleHandshakeMessage,\r\n            \"ACCEPT\":           handleAcceptMessage,\r\n            \"MESSAGE\":          handleMessage,\r\n            \"CLOSE-CONNECTION\": handleCloseConnection\r\n        }\r\n\r\n        self.getWebSocketRpc = function() {\r\n          return webSocketRpc;\r\n        }\r\n\r\n        webSocketRpc.registerPushHandler(\"ENDPOINT_MESSAGE\", function(event){\r\n            var message = event.data;\r\n\r\n            var endOfLine = message.indexOf(\"\\n\");\r\n\r\n            var sourceEva;\r\n            if(endOfLine == -1) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(\"WebSocketHub: Malformed message retrieved. EOL character is required after endpoint\\n\" + message);\r\n                return;\r\n            }\r\n            var sourceEva = message.substr(0, endOfLine);\r\n\r\n            var beginOfLine = endOfLine + 1;\r\n            endOfLine = message.indexOf(\"\\n\", beginOfLine);\r\n            var messageType;\r\n            var body;\r\n            if(endOfLine == -1) {\r\n                messageType = message.substr(beginOfLine);\r\n                body = null;\r\n            }else{\r\n                messageType = message.substr(beginOfLine, endOfLine - beginOfLine);\r\n                body = message.substr(endOfLine + 1);\r\n            }\r\n\r\n            var handler = messageHandlers[messageType];\r\n\r\n            if(!handler) {\r\n                throw new Error(\"WebSocketHub: Unexpected message type: '\" + messageType + \"'\");\r\n            }\r\n\r\n            handler(sourceEva, messageType, body);\r\n        })\r\n\r\n        self.__doSend = function(connection, message) {\r\n            webSocketRpc.invoke(\"SEND_TO_ENDPOINT\",  connection.targetEva + \"\\nMESSAGE\\n\" + message, {retryResend: true})\r\n            .then(function(event){\r\n                if(event.data == _global_js__WEBPACK_IMPORTED_MODULE_1__.Global.SEND_TO_ENDPOINT_RECIPIENT_ENDPOINT_CANNOT_BE_FOUND) {\r\n                    self.closeConnection(connection.targetEva);\r\n                }\r\n            })\r\n            .catch((e) => _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(\"websocket-hub\", \"SEND_TO_ENDPOINT MESSAGE not delivered: \" + e));\r\n        };\r\n\r\n        var parentDestroy = self.destroy;\r\n        self.destroy = function() {\r\n            parentDestroy();\r\n            webSocketRpc.releaseUsage();\r\n        };\r\n    };\r\n};\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/channel/websocket-hub.js?");

/***/ }),

/***/ "./src/vnf/global.js":
/*!***************************!*\
  !*** ./src/vnf/global.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Global\": () => (/* binding */ Global)\n/* harmony export */ });\nvar Global = {\r\n     OK :       \"OK\",\r\n     CONNECTED: \"CONNECTED\",\r\n     FAILED:    \"FAILED\",\r\n\r\n     SEND_TO_ENDPOINT_RECIPIENT_ENDPOINT_CANNOT_BE_FOUND: \"SEND_TO_ENDPOINT_RECIPIENT_ENDPOINT_CANNOT_BE_FOUND\",\r\n\r\n     GET_FAILED_ENTRY_NOT_FOUND            : \"GET_FAILED_ENTRY_NOT_FOUND\",\r\n     DELETE_FAILED_ENTRY_NOT_FOUND         : \"DELETE_FAILED_ENTRY_NOT_FOUND\",\r\n     CREATE_FAILED_ENTRY_ALREADY_EXISTS    : \"CREATE_FAILED_ENTRY_ALREADY_EXISTS\",\r\n     UPDATE_FAILED_DUE_TO_OWNERSHIP_CHECK  : \"UPDATE_FAILED_DUE_TO_OWNERSHIP_CHECK\",\r\n     DELETE_FAILED_DUE_TO_OWNERSHIP_CHECK  : \"DELETE_FAILED_DUE_TO_OWNERSHIP_CHECK\",\r\n\r\n     CALL_FAILED_UNKNOWN_METHOD       : \"CALL_FAILED_UNKNOWN_METHOD\",\r\n     CALL_FAILED_UNEXPECTED_EXCEPTION : \"CALL_FAILED_UNEXPECTED_EXCEPTION\",\r\n\r\n     FAILED_DUE_TO_CONNECTION_LOST    : \"FAILED_DUE_TO_CONNECTION_LOST\",\r\n     REJECTED_BY_TIMEOUT              : \"REJECTED_BY_TIMEOUT\",\r\n\r\n     INSTANCE_DESTROYED: \"INSTANCE_DESTROYED\"\r\n }\r\n\r\n\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/global.js?");

/***/ }),

/***/ "./src/vnf/registry/in-browser-registry.js":
/*!*************************************************!*\
  !*** ./src/vnf/registry/in-browser-registry.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InBrowserRegistry\": () => (/* binding */ InBrowserRegistry)\n/* harmony export */ });\n/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils.js */ \"./src/utils/utils.js\");\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../global.js */ \"./src/vnf/global.js\");\n\r\n\r\n\r\n\r\nfunction validateKey(key) {\r\n    if(key.collection.indexOf(\"\\n\") != -1) throw new Error(\"WebSocketRegistry EOL character isn't supported in collection name\");\r\n    if(key.name.indexOf(\"\\n\") != -1) throw new Error(\"WebSocketRegistry EOL character isn't supported in entry name\");\r\n}\r\n\r\nfunction InBrowserRegistry() {\r\n    var clients = {};\r\n\r\n    var collections = {}\r\n\r\n    function InBrowserRegistryClient(eva) {\r\n\r\n        var ownedKeyLastIndex = 0;\r\n        var ownedKeys     = {};\r\n\r\n        function putEntry(failIfExists, key, value) {\r\n            validateKey(key);\r\n\r\n            return new Promise(function(resolve, reject){\r\n                if(!collections[key.collection]) {\r\n                    collections[key.collection] = {}\r\n                }\r\n\r\n                var oldValue = collections[key.collection][key.name];\r\n                if(oldValue) {\r\n                    if(failIfExists) {\r\n                        reject(_global_js__WEBPACK_IMPORTED_MODULE_1__.Global.CREATE_FAILED_ENTRY_ALREADY_EXISTS)\r\n                        return;\r\n                    }\r\n\r\n                    if(oldValue.owner != eva) {\r\n                        reject(_global_js__WEBPACK_IMPORTED_MODULE_1__.Global.UPDATE_FAILED_DUE_TO_OWNERSHIP_CHECK);\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                var ownedKeyIndex = ownedKeyLastIndex++;\r\n                ownedKeys[ownedKeyIndex] = key;\r\n                collections[key.collection][key.name] = {owner: eva,\r\n                                                         value: value,\r\n                                                         ownedKeyIndex: ownedKeyIndex}\r\n\r\n                resolve(_global_js__WEBPACK_IMPORTED_MODULE_1__.Global.OK);\r\n            })\r\n        }\r\n\r\n        function removeEntry(key) {\r\n            var collection = collections[key.collection];\r\n            var entry = collection && collection[key.name];\r\n\r\n            if(!entry) {\r\n                return _global_js__WEBPACK_IMPORTED_MODULE_1__.Global.DELETE_FAILED_ENTRY_NOT_FOUND;\r\n            }\r\n\r\n            if(entry.owner != eva) {\r\n                return _global_js__WEBPACK_IMPORTED_MODULE_1__.Global.DELETE_FAILED_DUE_TO_OWNERSHIP_CHECK;\r\n            }\r\n\r\n            delete ownedKeys[entry.ownedKeyIndex];\r\n            delete collection[key.name];\r\n\r\n            if(_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.Utils.isEmptyObject(collection)) {\r\n                delete collections[key.collection];\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n\r\n        this.createOrUpdate = function createEntry(key, value) {\r\n            return putEntry(false, key, value);\r\n        }\r\n\r\n        this.createEntry = function createEntry(key, value) {\r\n            return putEntry(true, key, value);\r\n        }\r\n\r\n        this.getEntry = function(key, value) {\r\n            validateKey(key);\r\n\r\n            return new Promise(function(resolve, reject){\r\n                var collection = collections[key.collection];\r\n                var entry = collection && collection[key.name];\r\n\r\n                if(!entry) {\r\n                    reject(_global_js__WEBPACK_IMPORTED_MODULE_1__.Global.GET_FAILED_ENTRY_NOT_FOUND);\r\n                    return;\r\n                }\r\n\r\n                return resolve(entry.value);\r\n            })\r\n        }\r\n\r\n        this.getEntriesWithBody = function(collection) {\r\n            if(collection.indexOf(\"\\n\") != -1) throw new Error(\"WebSocketRegistry EOL character isn't supported in collection name\");\r\n\r\n            return new Promise(function(resolve){\r\n                var collectionSet = collections[collection];\r\n\r\n                var result = {};\r\n\r\n                if(collectionSet) {\r\n                    for (var prop in collectionSet) {\r\n                      result[prop] = collectionSet[prop].value;\r\n                    }\r\n                }\r\n\r\n                return resolve(result);\r\n            });\r\n        }\r\n\r\n        this.deleteEntry = function(key) {\r\n            validateKey(key);\r\n\r\n            return new Promise(function(resolve, reject){\r\n                var errorCode = removeEntry(key);\r\n\r\n                if(!errorCode) {\r\n                    resolve(_global_js__WEBPACK_IMPORTED_MODULE_1__.Global.OK);\r\n\r\n                }else{\r\n                    reject(errorCode);\r\n                }\r\n            })\r\n        }\r\n\r\n        this.destroy = function() {\r\n            delete clients[eva];\r\n\r\n            for(var prop in ownedKeys){\r\n                removeEntry(ownedKeys[prop]);\r\n            }\r\n        }\r\n    }\r\n\r\n    this.connect = function connect(eva) {\r\n        if(clients[eva]) {\r\n            throw new Error(\"This name already in used\");\r\n        }\r\n\r\n        clients[eva] = new InBrowserRegistryClient(eva);\r\n\r\n        return clients[eva];\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/registry/in-browser-registry.js?");

/***/ }),

/***/ "./src/vnf/registry/websocket-registry-client.js":
/*!*******************************************************!*\
  !*** ./src/vnf/registry/websocket-registry-client.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebSocketRegistryClient\": () => (/* binding */ WebSocketRegistryClient)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils.js */ \"./src/utils/utils.js\");\n/* harmony import */ var _utils_vnf_serializer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/vnf-serializer.js */ \"./src/utils/vnf-serializer.js\");\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../global.js */ \"./src/vnf/global.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nfunction WebSocketRegistryClient(webSocketRpc) {\r\n\r\n    webSocketRpc.allocateUsage();\r\n\r\n    var WebSocketRegistryClient = this;\r\n    var registryCache = {}\r\n\r\n    function putToCache(key, value) {\r\n        var collection = registryCache[key.collection];\r\n\r\n        if(!collection) {\r\n            collection= {}\r\n            registryCache[key.collection] = collection;\r\n        }\r\n\r\n        collection[key.name] = value;\r\n    }\r\n\r\n    function deleteFromCache(key) {\r\n        var collection = registryCache[key.collection];\r\n\r\n        if(!collection) return;\r\n\r\n        delete collection[key.name];\r\n\r\n        if(_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.Utils.isEmptyObject(collection)) {\r\n            delete registryCache[key.collection];\r\n        }\r\n    }\r\n\r\n    webSocketRpc.onConnectionOpen(function rpcOnConnectionOpenCallback(){\r\n        for(var collectionName in registryCache) {\r\n            var collection = registryCache[collectionName];\r\n\r\n            for(var entryName in collection) {\r\n                WebSocketRegistryClient.createOrUpdate({collection: collectionName, name: entryName}, collection[entryName])\r\n                .catch((e) => _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(\"websocket-registry-client\", \"Unable to createOrUpdate cached object on connection open: \", e));\r\n            }\r\n        }\r\n\r\n        registryCache = {}\r\n    })\r\n\r\n    function validateKey(key) {\r\n        if(key.collection.indexOf(\"\\n\") != -1) throw new Error(\"WebSocketRegistry EOL character isn't supported in collection name\");\r\n        if(key.name.indexOf(\"\\n\") != -1) throw new Error(\"WebSocketRegistry EOL character isn't supported in entry name\");\r\n    }\r\n\r\n    this.createEntry = function(key, value) {\r\n        validateKey(key);\r\n\r\n        return webSocketRpc.invoke(\"CREATE-ENTRY\", key.collection + \"\\n\" + key.name + \"\\n\" + _utils_vnf_serializer_js__WEBPACK_IMPORTED_MODULE_2__.VnfSerializer.serializeValue(value))\r\n        .then(function(evt) {\r\n            if(evt.data == _global_js__WEBPACK_IMPORTED_MODULE_3__.Global.OK) {\r\n                putToCache(key, value);\r\n            }\r\n\r\n            return evt.data;\r\n        });\r\n    }\r\n\r\n    this.createOrUpdate = function(key, value) {\r\n        validateKey(key);\r\n\r\n        return webSocketRpc.invoke(\"CREATE-OR-UPDATE-ENTRY\", key.collection + \"\\n\" + key.name + \"\\n\" + _utils_vnf_serializer_js__WEBPACK_IMPORTED_MODULE_2__.VnfSerializer.serializeValue(value),{retryResend: true})\r\n        .then(function(evt) {\r\n            if(evt.data == _global_js__WEBPACK_IMPORTED_MODULE_3__.Global.OK) {\r\n                putToCache(key, value);\r\n            }\r\n\r\n            return evt.data;\r\n        });\r\n    }\r\n\r\n    this.getEntry = function(key, value) {\r\n        validateKey(key);\r\n\r\n        return webSocketRpc.invoke(\"GET-ENTRY\", key.collection + \"\\n\" + key.name, {retryResend: true})\r\n        .then(function(evt) {\r\n            return _utils_vnf_serializer_js__WEBPACK_IMPORTED_MODULE_2__.VnfSerializer.deserializeValue(evt.data);\r\n        });\r\n    }\r\n\r\n    this.getEntriesWithBody = function(collection) {\r\n        if(collection.indexOf(\"\\n\") != -1) throw new Error(\"EOL character isn't supported in collection name\");\r\n\r\n        return webSocketRpc.invoke(\"GET-ENTRIES-WITH-BODY\", collection, {retryResend: true})\r\n        .then(function(evt){\r\n            var result = {};\r\n\r\n            var message = evt.data;\r\n\r\n            var index = 0;\r\n            while(index < message.length) {\r\n                var spaceCharacterIndex = message.indexOf(\" \", index);\r\n                var eolCharacterIndex = message.indexOf(\"\\n\", spaceCharacterIndex);\r\n\r\n                var entryValueLength = message.substr(index, spaceCharacterIndex - index) - 0;\r\n                var entryName  = message.substr(spaceCharacterIndex + 1, eolCharacterIndex - spaceCharacterIndex - 1);\r\n                var entryValue = message.substr(eolCharacterIndex + 1, entryValueLength);\r\n\r\n                index = eolCharacterIndex + entryValueLength + 2;\r\n\r\n                if(spaceCharacterIndex == -1 || eolCharacterIndex == -1 || isNaN(entryValueLength)) {\r\n                    throw new Error(\"WebSocketRegistry Malformed response for getEntriesWithBody from server, response: \" + message);\r\n                }\r\n\r\n                result[entryName] = _utils_vnf_serializer_js__WEBPACK_IMPORTED_MODULE_2__.VnfSerializer.deserializeValue(entryValue);\r\n            }\r\n\r\n            return result;\r\n        });\r\n    }\r\n\r\n    this.deleteEntry = function(key) {\r\n        validateKey(key);\r\n\r\n        return webSocketRpc.invoke(\"DELETE-ENTRY\", key.collection + \"\\n\" + key.name, {retryResend: true})\r\n        .then(function(evt) {\r\n            if(evt.data == _global_js__WEBPACK_IMPORTED_MODULE_3__.Global.OK) {\r\n                deleteFromCache(key);\r\n            }\r\n            return evt.data;\r\n        });\r\n    }\r\n\r\n    this.destroy = function() {\r\n        webSocketRpc.releaseUsage();\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/registry/websocket-registry-client.js?");

/***/ }),

/***/ "./src/vnf/system/service/channel-hub-service.js":
/*!*******************************************************!*\
  !*** ./src/vnf/system/service/channel-hub-service.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ChannelHubService\": () => (/* binding */ ChannelHubService)\n/* harmony export */ });\nfunction ChannelHubService(hub) {\r\n    return function(vnfEndpoint) {\r\n        return {\"initializeEndpoint\": function(){\r\n            return hub.openEndpoint(vnfEndpoint.eva);\r\n        }}\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/system/service/channel-hub-service.js?");

/***/ }),

/***/ "./src/vnf/system/service/service-call-service.js":
/*!********************************************************!*\
  !*** ./src/vnf/system/service/service-call-service.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ServiceCallService\": () => (/* binding */ ServiceCallService)\n/* harmony export */ });\n/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils.js */ \"./src/utils/utils.js\");\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global.js */ \"./src/vnf/global.js\");\n\r\n\r\n\r\n\r\n\r\nvar MESSAGE_TYPE_CALL          = \"CALL\";\r\nvar MESSAGE_TYPE_RESPONSE      = \"RESPONSE\";\r\nvar MESSAGE_TYPE_RESPONSE_FAIL = \"RESPONSE-FAIL\";\r\n\r\nfunction ServiceCallService(storeHub) {\r\n    return function(vnfEndpoint) {\r\n        var callbackMap = {};\r\n        var nextTokenId = 0;\r\n        var handlersRegistry = {};\r\n\r\n        var callTimeout = 2*60*1000;\r\n        var timerActive = false;\r\n\r\n        function onTimerEvent() {\r\n            var timerActive = false;\r\n            var callbacksMapEmpty = true;\r\n\r\n            for(var eva in callbackMap) {\r\n                var evaCallbacks = callbackMap[eva];\r\n\r\n                if(_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.Utils.isEmptyObject(evaCallbacks)) {\r\n                    delete callbackMap[eva];\r\n                    continue;\r\n                }\r\n\r\n                for(var token in evaCallbacks) {\r\n                    var callbacks = evaCallbacks[token];\r\n                    callbacks.timeToLive--;\r\n                    if(callbacks.timeToLive == 0) {\r\n                        delete evaCallbacks[token];\r\n                        callbacks.reject(_global_js__WEBPACK_IMPORTED_MODULE_1__.Global.REJECTED_BY_TIMEOUT);\r\n                    }\r\n                }\r\n\r\n                callbacksMapEmpty = false;\r\n            }\r\n\r\n            // reject callback can make a call, which will re-initiate timer\r\n            // extra check that timer wasn't executed\r\n            if(!timerActive && !callbacksMapEmpty) {\r\n                timerActive = true;\r\n                window.setTimeout(onTimerEvent, callTimeout);\r\n            }\r\n        }\r\n\r\n        vnfEndpoint.setCallTimeout = function(value) {\r\n            callTimeout = value;\r\n        }\r\n\r\n        function sendResult(event, result) {\r\n            vnfEndpoint.send(event.sourceEva, {\r\n                type:   MESSAGE_TYPE_RESPONSE,\r\n                token:  event.message.token,\r\n                result: result\r\n            })\r\n        }\r\n\r\n        function sendReject(event, reason) {\r\n            vnfEndpoint.send(event.sourceEva, {\r\n                type:   MESSAGE_TYPE_RESPONSE_FAIL,\r\n                token:  event.message.token,\r\n                reason: reason\r\n            })\r\n        }\r\n\r\n        function handleCall(event) {\r\n            var message = event.message;\r\n            var handler = handlersRegistry[message.method];\r\n            if(!handler) {\r\n                sendReject(event, _global_js__WEBPACK_IMPORTED_MODULE_1__.Global.CALL_FAILED_UNKNOWN_METHOD);\r\n                return;\r\n            }\r\n\r\n            Promise.resolve()\r\n            .then(handler.bind(null,\r\n                    { message: message.argument,\r\n                      method:  message.method,\r\n                      sourceEva: event.sourceEva,\r\n                      endpoint: vnfEndpoint }))\r\n            .then(function(value){\r\n                if(value instanceof Error) {\r\n                    sendReject(event, value.message);\r\n                }else{\r\n                    sendResult(event, value);\r\n                }\r\n            },function(){\r\n                sendReject(event, _global_js__WEBPACK_IMPORTED_MODULE_1__.Global.CALL_FAILED_UNEXPECTED_EXCEPTION);\r\n            })\r\n        }\r\n\r\n        function handleResponse(event) {\r\n            var message = event.message;\r\n            var evaCallbacks = callbackMap[event.sourceEva];\r\n            var callbacks = evaCallbacks && evaCallbacks[message.token];\r\n            if(callbacks) {\r\n                delete evaCallbacks[message.token];\r\n                callbacks.resolve(message.result);\r\n            }\r\n        }\r\n\r\n        function handleResponseFailed(event) {\r\n            var message = event.message;\r\n            var evaCallbacks = callbackMap[event.sourceEva];\r\n            var callbacks = evaCallbacks && evaCallbacks[message.token];\r\n            if(callbacks) {\r\n                delete evaCallbacks[message.token];\r\n                callbacks.reject(message.reason);\r\n            }\r\n        }\r\n\r\n        function vnfPush(eva, method, argument) {\r\n            vnfEndpoint.send(eva, {\r\n               type: MESSAGE_TYPE_CALL,\r\n               token: nextTokenId++,\r\n               method: method,\r\n               argument: argument\r\n           })\r\n        }\r\n\r\n        function vnfCall(eva, method, argument) {\r\n            return new Promise(function(resolve, reject){\r\n                var tokenId = nextTokenId;\r\n                var evaCallbacks = callbackMap[eva];\r\n\r\n                if(!timerActive) {\r\n                    timerActive = true;\r\n                    window.setTimeout(onTimerEvent, callTimeout);\r\n                }\r\n\r\n                if(!evaCallbacks) {\r\n                    evaCallbacks = {}\r\n                    callbackMap[eva] = evaCallbacks;\r\n                }\r\n\r\n                evaCallbacks[tokenId] = {\r\n                   timeToLive: 2,\r\n                   resolve: resolve,\r\n                   reject: reject\r\n                }\r\n\r\n                vnfPush(eva, method, argument);\r\n           })\r\n        }\r\n\r\n        function onConnectionLost(targetEva) {\r\n            var evaCallbacks = callbackMap[targetEva];\r\n\r\n            if(!evaCallbacks) return;\r\n\r\n            for(var token in evaCallbacks) {\r\n                evaCallbacks[token].reject(_global_js__WEBPACK_IMPORTED_MODULE_1__.Global.FAILED_DUE_TO_CONNECTION_LOST);\r\n                delete evaCallbacks[token];\r\n            }\r\n        }\r\n\r\n        return {\r\n            initialize: function() {\r\n                var handlers = vnfEndpoint.serviceLookupCall(\"handlers\");\r\n                var messageHandlers = vnfEndpoint.serviceLookupCall(\"messageHandlers\");\r\n                for(var i = 0; i < handlers.length; i++) {\r\n                    var handlers = handlers[i];\r\n                    for(var methods in handlers) {\r\n                        handlersRegistry[methods] = handlers[methods];\r\n                    }\r\n                }\r\n\r\n                vnfEndpoint.call = vnfCall;\r\n                vnfEndpoint.push = vnfPush;\r\n            },\r\n\r\n            messageHandlers: {\r\n                \"CALL\":          handleCall,\r\n                \"RESPONSE\":      handleResponse,\r\n                \"RESPONSE-FAIL\": handleResponseFailed\r\n            },\r\n\r\n            onConnectionLost: onConnectionLost\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/system/service/service-call-service.js?");

/***/ }),

/***/ "./src/vnf/system/service/store-service.js":
/*!*************************************************!*\
  !*** ./src/vnf/system/service/store-service.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"StoreService\": () => (/* binding */ StoreService)\n/* harmony export */ });\nfunction StoreService(storeHub) {\r\n    return function(vnfEndpoint) {\r\n        return {\"initializeStoreClient\": function(){\r\n            return storeHub.connect(vnfEndpoint.eva);\r\n        }}\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/system/service/store-service.js?");

/***/ }),

/***/ "./src/vnf/system/service/vnf-core-service.js":
/*!****************************************************!*\
  !*** ./src/vnf/system/service/vnf-core-service.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VnfCoreService\": () => (/* binding */ VnfCoreService)\n/* harmony export */ });\n\r\nfunction VnfCoreService() {\r\n    return function(vnfEndpoint) {\r\n        var parentEndpoint;\r\n        var storeClient;\r\n\r\n        var handlersRegistry = {}\r\n\r\n        function onMessage(event) {\r\n            var handler = handlersRegistry[event.message.type];\r\n            handler && handler(event);\r\n        }\r\n\r\n        return {\r\n            initialize: function() {\r\n                var messageHandlers = vnfEndpoint.serviceLookupCall(\"messageHandlers\");\r\n                for(var i = 0; i < messageHandlers.length; i++) {\r\n                    var messageHandler = messageHandlers[i];\r\n                    for(var messageType in messageHandler) {\r\n                        handlersRegistry[messageType] = messageHandler[messageType];\r\n                    }\r\n                }\r\n\r\n                parentEndpoint = vnfEndpoint.serviceLookupCallSingle(\"initializeEndpoint\");\r\n                storeClient    = vnfEndpoint.serviceLookupCallSingle(\"initializeStoreClient\");\r\n\r\n                vnfEndpoint.send = parentEndpoint.send;\r\n                vnfEndpoint.closeConnection = parentEndpoint.closeConnection;\r\n                parentEndpoint.onMessage = onMessage;\r\n\r\n                vnfEndpoint.getStoreClient = function() {\r\n                    return storeClient;\r\n                }\r\n\r\n                parentEndpoint.onConnectionLost(function(targetEva){\r\n                    vnfEndpoint.serviceLookupCall(\"onConnectionLost\", targetEva)\r\n                });\r\n            },\r\n\r\n            destroy: function() {\r\n                parentEndpoint.destroy();\r\n                storeClient.destroy();\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/system/service/vnf-core-service.js?");

/***/ }),

/***/ "./src/vnf/system/system.js":
/*!**********************************!*\
  !*** ./src/vnf/system/system.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VnfSystem\": () => (/* binding */ VnfSystem)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../global.js */ \"./src/vnf/global.js\");\n/* harmony import */ var _service_vnf_core_service_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./service/vnf-core-service.js */ \"./src/vnf/system/service/vnf-core-service.js\");\n/* harmony import */ var _service_service_call_service_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./service/service-call-service.js */ \"./src/vnf/system/service/service-call-service.js\");\n/* harmony import */ var _service_channel_hub_service_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./service/channel-hub-service.js */ \"./src/vnf/system/service/channel-hub-service.js\");\n/* harmony import */ var _service_store_service_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./service/store-service.js */ \"./src/vnf/system/service/store-service.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction VnfSystem() {\r\n    var vnfSystem = this;\r\n\r\n    var endpoints = {}\r\n    var serviceFactories = [];\r\n\r\n    function VnfSystemEndpoint(eva) {\r\n        var vnfEndpoint = this;\r\n        vnfEndpoint.eva = eva;\r\n\r\n        var serviceList = [];\r\n\r\n        for(var i = 0; i < serviceFactories.length; i++) {\r\n            var factoryMethod = serviceFactories[i];\r\n            serviceList.push(new factoryMethod(vnfEndpoint));\r\n        }\r\n\r\n        this.serviceLookupCallSingle = function(method, argument) {\r\n            var result = vnfEndpoint.serviceLookupCall(method, argument);\r\n            if(result.length != 1) {\r\n                throw new Error(\"Service lookup single result excepted while \" + result.length + \" found, method: \" + method)\r\n            }\r\n\r\n            return result[0];\r\n        }\r\n\r\n        this.serviceLookupCall = function(method, argument) {\r\n            var result = [];\r\n            for(var i = 0; i < serviceList.length; i++) {\r\n                try{\r\n                    var value = serviceList[i][method];\r\n                    if(value) {\r\n                        if(typeof value == \"function\") {\r\n                            result.push(value(argument))\r\n                        }else{\r\n                            result.push(value)\r\n                        }\r\n                    }\r\n                }catch(e) {\r\n                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(eva, \"VnfSystem\", [\"Service lookup call failed\", e]);\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        this.destroy = function() {\r\n            vnfEndpoint.serviceLookupCall(\"destroy\");\r\n            delete endpoints[eva];\r\n        }\r\n\r\n        this.serviceLookupCall(\"initialize\");\r\n    }\r\n\r\n    this.registerService = function(serviceFactory) {\r\n        if(!serviceFactory) throw new Error(\"registerService(undefined) called\");\r\n\r\n        serviceFactories.push(serviceFactory);\r\n    }\r\n\r\n    this.openEndpoint = function(eva) {\r\n        var endpoint = endpoints[eva];\r\n        if(!endpoint) {\r\n            endpoint = new VnfSystemEndpoint(eva);\r\n            endpoints[eva] = endpoint;\r\n        }\r\n        return endpoint;\r\n    }\r\n\r\n    this.registerService(new _service_vnf_core_service_js__WEBPACK_IMPORTED_MODULE_2__.VnfCoreService())\r\n    this.registerService(new _service_service_call_service_js__WEBPACK_IMPORTED_MODULE_3__.ServiceCallService())\r\n}\r\n\r\nVnfSystem.ChannelHubService = _service_channel_hub_service_js__WEBPACK_IMPORTED_MODULE_4__.ChannelHubService;\r\nVnfSystem.StoreService      = _service_store_service_js__WEBPACK_IMPORTED_MODULE_5__.StoreService;\r\n\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/system/system.js?");

/***/ }),

/***/ "./src/vnf/vnf.js":
/*!************************!*\
  !*** ./src/vnf/vnf.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vnf\": () => (/* binding */ Vnf)\n/* harmony export */ });\n/* harmony import */ var _utils_arrays_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/arrays.js */ \"./src/utils/arrays.js\");\n/* harmony import */ var _utils_arrays_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_utils_arrays_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./global.js */ \"./src/vnf/global.js\");\n/* harmony import */ var _websocket_websocket_rpc_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./websocket/websocket-rpc.js */ \"./src/vnf/websocket/websocket-rpc.js\");\n/* harmony import */ var _websocket_websocket_facrory_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./websocket/websocket-facrory.js */ \"./src/vnf/websocket/websocket-facrory.js\");\n/* harmony import */ var _registry_in_browser_registry_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./registry/in-browser-registry.js */ \"./src/vnf/registry/in-browser-registry.js\");\n/* harmony import */ var _registry_websocket_registry_client_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./registry/websocket-registry-client.js */ \"./src/vnf/registry/websocket-registry-client.js\");\n/* harmony import */ var _channel_in_browser_hub_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./channel/in-browser-hub.js */ \"./src/vnf/channel/in-browser-hub.js\");\n/* harmony import */ var _channel_rtc_hub_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./channel/rtc-hub.js */ \"./src/vnf/channel/rtc-hub.js\");\n/* harmony import */ var _channel_marshaller_channel_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./channel/marshaller-channel.js */ \"./src/vnf/channel/marshaller-channel.js\");\n/* harmony import */ var _channel_unreliable_hub_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./channel/unreliable-hub.js */ \"./src/vnf/channel/unreliable-hub.js\");\n/* harmony import */ var _channel_reliable_hub_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./channel/reliable-hub.js */ \"./src/vnf/channel/reliable-hub.js\");\n/* harmony import */ var _channel_reliable_rtc_hub_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./channel/reliable-rtc-hub.js */ \"./src/vnf/channel/reliable-rtc-hub.js\");\n/* harmony import */ var _channel_websocket_hub_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./channel/websocket-hub.js */ \"./src/vnf/channel/websocket-hub.js\");\n/* harmony import */ var _system_system_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./system/system.js */ \"./src/vnf/system/system.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar Vnf = {\r\n      Global: _global_js__WEBPACK_IMPORTED_MODULE_1__.Global,\r\n\r\n      WebSocketRpc: _websocket_websocket_rpc_js__WEBPACK_IMPORTED_MODULE_2__.WebSocketRpc,\r\n      WebSocketFactory: _websocket_websocket_facrory_js__WEBPACK_IMPORTED_MODULE_3__.WebSocketFactory,\r\n\r\n      InBrowserRegistry: _registry_in_browser_registry_js__WEBPACK_IMPORTED_MODULE_4__.InBrowserRegistry,\r\n      WebSocketRegistryClient: _registry_websocket_registry_client_js__WEBPACK_IMPORTED_MODULE_5__.WebSocketRegistryClient,\r\n\r\n      InBrowserHub: _channel_in_browser_hub_js__WEBPACK_IMPORTED_MODULE_6__.InBrowserHub,\r\n      UnreliableHub: _channel_unreliable_hub_js__WEBPACK_IMPORTED_MODULE_9__.UnreliableHub,\r\n      ReliableHub: _channel_reliable_hub_js__WEBPACK_IMPORTED_MODULE_10__.ReliableHub,\r\n      RtcHub: _channel_rtc_hub_js__WEBPACK_IMPORTED_MODULE_7__.RtcHub,\r\n      MarshallerHub: _channel_marshaller_channel_js__WEBPACK_IMPORTED_MODULE_8__.MarshallerHub,\r\n      ReliableRtcHub: _channel_reliable_rtc_hub_js__WEBPACK_IMPORTED_MODULE_11__.ReliableRtcHub,\r\n      WebSocketHub: _channel_websocket_hub_js__WEBPACK_IMPORTED_MODULE_12__.WebSocketHub,\r\n\r\n      System: _system_system_js__WEBPACK_IMPORTED_MODULE_13__.VnfSystem\r\n};\r\n\r\n\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/vnf.js?");

/***/ }),

/***/ "./src/vnf/websocket/websocket-facrory.js":
/*!************************************************!*\
  !*** ./src/vnf/websocket/websocket-facrory.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebSocketFactory\": () => (/* binding */ WebSocketFactory)\n/* harmony export */ });\nfunction WebSocketFactory(url) {\r\n    this.newWebSocket = function() {\r\n        return new WebSocket(url);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/websocket/websocket-facrory.js?");

/***/ }),

/***/ "./src/vnf/websocket/websocket-rpc.js":
/*!********************************************!*\
  !*** ./src/vnf/websocket/websocket-rpc.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebSocketRpc\": () => (/* binding */ WebSocketRpc)\n/* harmony export */ });\n/* harmony import */ var _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/logger.js */ \"./src/utils/logger.js\");\n/* harmony import */ var _utils_observable_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/observable.js */ \"./src/utils/observable.js\");\n/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/utils.js */ \"./src/utils/utils.js\");\n/* harmony import */ var _global_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../global.js */ \"./src/vnf/global.js\");\n\r\n\r\n\r\n\r\n\r\n\r\nfunction WebSocketRpc(eva, webSocketFactory) {\r\n    var webSocketRpc = this;\r\n    var webSocket = null;\r\n\r\n    var destroyed = false;\r\n\r\n    var connectionOpenListeners = new _utils_observable_js__WEBPACK_IMPORTED_MODULE_1__.Observable();\r\n\r\n    var callMap = {};\r\n    var handlers = {}\r\n\r\n    var nextCallId = 0;\r\n    var isConnected = false;\r\n\r\n    var busyTimerGotResponse = false;\r\n\r\n    var loginRecreateInterval =   30*1000;\r\n    var busyTimerInterval     =   20*1000;\r\n    var idleTimerInterval     = 5*60*1000;\r\n\r\n    var busyTimerToken = null;\r\n    var loginRecreateTimerToken = null;\r\n    var idleTimerToken = null;\r\n\r\n    var allocatedUsagesCounter = 0;\r\n\r\n    function onBusyTimer() {\r\n        // connection lost verification busy is the case when calls are made constantly to websocket\r\n\r\n        // check if at least on call got response\r\n        // if so then web socket connection alive\r\n        busyTimerToken = null;\r\n\r\n        if(destroyed || !isConnected) return;\r\n\r\n        if(!busyTimerGotResponse) {\r\n            recreateWebSocket();\r\n        }else{\r\n            busyTimerGotResponse = false;\r\n            if(!_utils_utils_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isEmptyObject(callMap)) {\r\n                startBusyTimer();\r\n            }else{\r\n                startIdleTimer();\r\n            }\r\n        }\r\n    }\r\n\r\n    function onIdleTimer() {\r\n        idleTimerToken = null;\r\n\r\n        if(destroyed || !isConnected) return;\r\n\r\n        webSocketRpc.verifyConnection();\r\n    }\r\n\r\n    function onLoginRecreationTimer() {\r\n        loginRecreateTimerToken = null;\r\n\r\n        if(destroyed || isConnected) return;\r\n\r\n        recreateWebSocket();\r\n    }\r\n\r\n\r\n    function stopAllTimers(){\r\n        if(idleTimerToken) {\r\n            window.clearTimeout(idleTimerToken);\r\n            idleTimerToken = null;\r\n        }\r\n\r\n         if(loginRecreateTimerToken) {\r\n            window.clearTimeout(loginRecreateTimerToken);\r\n            loginRecreateTimerToken = null;\r\n        }\r\n\r\n        if(busyTimerToken) {\r\n            window.clearTimeout(busyTimerToken);\r\n            busyTimerToken = null;\r\n        }\r\n    }\r\n\r\n    function startBusyTimer() {\r\n        stopAllTimers();\r\n\r\n        busyTimerToken = window.setTimeout(onBusyTimer, busyTimerInterval);\r\n    }\r\n\r\n    function startIdleTimer() {\r\n        stopAllTimers();\r\n        idleTimerToken = window.setTimeout(onIdleTimer, idleTimerInterval);\r\n    }\r\n\r\n\r\n    function startLoginRecreateTimer() {\r\n        stopAllTimers();\r\n        loginRecreateTimerToken = window.setTimeout(onLoginRecreationTimer, loginRecreateInterval);\r\n    }\r\n\r\n    function closeWebSocket() {\r\n        var previousWebSocket = webSocket;\r\n        webSocket = null;\r\n\r\n        try{\r\n            if(previousWebSocket) {\r\n                previousWebSocket.onopen = function(){};\r\n                previousWebSocket.onmessage = function(){};\r\n                previousWebSocket.onclose = function(){};\r\n\r\n                previousWebSocket.close()\r\n            }\r\n        }catch(error) {\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(eva, \"websocket-rtc\", [new Error(\"Unable to close websocket\"), error]);\r\n        }\r\n    }\r\n\r\n    function recreateWebSocket() {\r\n        closeWebSocket();\r\n        createWebSocket();\r\n    }\r\n\r\n\r\n    function createWebSocket() {\r\n        webSocket = webSocketFactory.newWebSocket();\r\n        isConnected = false;\r\n\r\n        for(var header in callMap) {\r\n            var callAction = callMap[header];\r\n            if(!callAction.retryResend) {\r\n                delete callMap[header];\r\n\r\n                callAction.reject(_global_js__WEBPACK_IMPORTED_MODULE_3__.Global.REJECTED_BY_TIMEOUT);\r\n            }\r\n        }\r\n\r\n        webSocket.onopen = function() {\r\n            if(destroyed) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(eva, \"websocket-rtc\", [new Error(\"webscoket destroyed but websocket.onopen signal captured\")]);\r\n                return;\r\n            }\r\n\r\n            _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(eva, \"websocket-rtc\", [\"webSocket open: sending LOGIN\"]);\r\n\r\n            webSocketRpc.invoke(\"LOGIN\", eva, {immediateSend: true})\r\n            .then(function(result){\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.verbose(eva, \"websocket-rtc\", [\"webSocket LOGIN response: '\" + result.data + \"'\" ]);\r\n\r\n                if(result.data != \"OK\") {\r\n                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(eva, \"websocket-rtc\", [new Error(\"Login failed, retrying, error reason is '\" +  result.data + \"'\")]);\r\n                    return;\r\n                }\r\n\r\n                isConnected = true;\r\n                for(var header in callMap) {\r\n                    var callAction = callMap[header];\r\n\r\n                    try{\r\n                        webSocket.send(callAction.message);\r\n                    }catch(error) {\r\n                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(eva, \"websocket-rtc\", [\"Unable to send message via websocket: \", error]);\r\n                    }\r\n\r\n                }\r\n\r\n                connectionOpenListeners.fire();\r\n\r\n                if(!_utils_utils_js__WEBPACK_IMPORTED_MODULE_2__.Utils.isEmptyObject(callMap)) {\r\n                    startBusyTimer();\r\n                }else{\r\n                    startIdleTimer();\r\n                }\r\n            })\r\n            .catch((e)=> _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(eva, \"websocket-rtc\", [\"Unable to send LOGIN to server: \", e]));\r\n        }\r\n\r\n        webSocket.onmessage = function(event) {\r\n            if(destroyed) return;\r\n            if(event.target != webSocket) return;\r\n\r\n            busyTimerGotResponse = true;\r\n\r\n            var message = event.data;\r\n\r\n            var lineBreakIndex = message.indexOf('\\n');\r\n\r\n            var header;\r\n            var argument;\r\n\r\n            if(lineBreakIndex == -1) {\r\n                header = message;\r\n                argument = null;\r\n            }else{\r\n                var header   = message.substr(0, lineBreakIndex);\r\n                var argument = message.substr(lineBreakIndex+1);\r\n            }\r\n\r\n            try {\r\n\r\n                var handler = handlers[header];\r\n                handler && handler(header, argument);\r\n\r\n                var callAction = callMap[header];\r\n                callAction && handleCallResponse(callAction, header, argument);\r\n\r\n                if(!handler && !callAction) {\r\n                    _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(\"WebSocketRpc: Unexpected message header: '\" + header + \"'\");\r\n                }\r\n\r\n            }catch(error) {\r\n                _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.error(eva, \"websocket-rtc\", error);\r\n            }\r\n        }\r\n\r\n        webSocket.onclose = function(evt) {\r\n            if(destroyed) return;\r\n\r\n            if(evt.target == webSocket) {\r\n                createWebSocket();\r\n            }\r\n        }\r\n\r\n        startLoginRecreateTimer();\r\n    }\r\n\r\n    function handleCallResponse(callAction, header, argument) {\r\n        var callIdBreakIndex = header.indexOf(' ');\r\n        var callId  = header.substr(0, callIdBreakIndex);\r\n        var command = header.substr(callIdBreakIndex + 1);\r\n\r\n        delete callMap[header];\r\n\r\n        callAction.resolve({\r\n            data:    argument,\r\n            command: command,\r\n            callId:  callId\r\n        });\r\n    }\r\n\r\n    this.isConnected = function() {\r\n        return isConnected;\r\n    }\r\n\r\n    this.setBusyTimerInterval = function(value) {\r\n        busyTimerInterval = value;\r\n    }\r\n\r\n    this.setIdleTimerInterval = function(value) {\r\n        idleTimerInterval = value;\r\n    }\r\n\r\n    this.setLoginRecreateInterval = function(value) {\r\n        loginRecreateInterval = value;\r\n\r\n        if(loginRecreateTimerToken) {\r\n            startLoginRecreateTimer();\r\n        }\r\n    }\r\n\r\n    this.onConnectionOpen = connectionOpenListeners.addListener;\r\n\r\n    this.registerPushHandler = function(command, callback) {\r\n        if(destroyed) return;\r\n\r\n        handlers[command] = function(header, argument) {\r\n            callback({\r\n                data: argument,\r\n                command: header\r\n            })\r\n        }\r\n    }\r\n\r\n    this.verifyConnection = function() {\r\n        webSocketRpc.invoke(\"PING\", null, {retryResend: true})\r\n        .catch((e)=> _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(eva, \"websocket-rtc\", \"Unable to send PING to server: \" + e));\r\n    }\r\n\r\n    this.invoke = function(command, valueArgument, callParameters) {\r\n        var future = webSocketRpc.invokeFuture(command, valueArgument, callParameters);\r\n        return future.promise;\r\n    }\r\n\r\n    this.invokeFuture = function(command, valueArgument, callParameters) {\r\n            if(command.indexOf(\"\\n\") != -1) {\r\n                throw new Error(\"End line character: '\\\\n' is not allowed for WebbSocketRpc method name\");\r\n            }\r\n\r\n            if(destroyed) {\r\n                return {\r\n                    cancel: cancel,\r\n                    promise: Promise.reject(_global_js__WEBPACK_IMPORTED_MODULE_3__.Global.INSTANCE_DESTROYED)\r\n                };\r\n            }\r\n\r\n            if(isConnected) {\r\n                startBusyTimer();\r\n            }\r\n\r\n            var cancelled = false;\r\n            var header;\r\n\r\n            function cancel() {\r\n                if(cancelled) {\r\n                    return;\r\n                }\r\n\r\n                if(callMap[header]) {\r\n                    callMap[header].resolve = function(){}\r\n                    callMap[header].reject = function(){}\r\n                    delete callMap[header];\r\n                }\r\n            }\r\n\r\n            var promise = new Promise(function (resolve, reject){\r\n\r\n                var callId = nextCallId++;\r\n\r\n                header = callId + \" \" + command;\r\n\r\n                var message;\r\n                if(valueArgument === null | valueArgument === undefined) {\r\n                    message = header;\r\n                }else{\r\n                    message = header + \"\\n\" + valueArgument;\r\n                }\r\n\r\n                callMap[header] = {\r\n                    message: message,\r\n                    resolve: resolve,\r\n                    reject:  reject,\r\n                    retryResend: callParameters && callParameters.retryResend\r\n                }\r\n\r\n                var immediateSend = callParameters && callParameters.immediateSend;\r\n\r\n                if(isConnected || immediateSend) {\r\n\r\n                    try{\r\n                        webSocket.send(message);\r\n                    }catch(error) {\r\n                        _utils_logger_js__WEBPACK_IMPORTED_MODULE_0__.Log.debug(eva, \"websocket-rtc\", [\"Unable to send message via websocket: \", error]);\r\n                    }\r\n                }\r\n            });\r\n\r\n            return {\r\n                cancel: cancel,\r\n                promise: promise\r\n            };\r\n        }\r\n\r\n    this.destroy = function() {\r\n        if(destroyed) return;\r\n\r\n        destroyed = true;\r\n\r\n        closeWebSocket();\r\n        stopAllTimers();\r\n\r\n        for(var header in callMap) {\r\n            var callAction = callMap[header];\r\n            delete callMap[header];\r\n            callAction.reject(_global_js__WEBPACK_IMPORTED_MODULE_3__.Global.INSTANCE_DESTROYED);\r\n        }\r\n    }\r\n\r\n    this.allocateUsage = function() {\r\n        if(destroyed) {\r\n            throw new Error(\"WebsocketRpc instance already destroyed\")\r\n        }\r\n\r\n        allocatedUsagesCounter++;\r\n    }\r\n\r\n    this.releaseUsage = function() {\r\n        if(destroyed) {\r\n            return;\r\n        }\r\n\r\n        if(--allocatedUsagesCounter == 0) {\r\n            webSocketRpc.destroy();\r\n        }\r\n    }\r\n\r\n    webSocketRpc.registerPushHandler(\"CALL_ERROR\", function(event) {\r\n        var message = event.data;\r\n        var lineBreakIndex = message.indexOf(\"\\n\");\r\n\r\n        var header   = message.substr(0, lineBreakIndex);\r\n        var errorCode = message.substr(lineBreakIndex+1);\r\n\r\n        var callAction = callMap[header];\r\n\r\n        delete callMap[header];\r\n\r\n        callAction.reject(errorCode);\r\n    })\r\n\r\n    createWebSocket();\r\n}\r\n\r\n\n\n//# sourceURL=webpack://Vnf/./src/vnf/websocket/websocket-rpc.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	Vnf = __webpack_exports__;
/******/ 	
/******/ })()
;